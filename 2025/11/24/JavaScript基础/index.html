<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript | March</title><meta name="author" content="March"><meta name="copyright" content="March"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript 是一门动态的，弱类型的，解释型的，基于对象的脚本语言。  动态： 程序执行的时候才会确定数据类型。 静态： 书写代码的时候提前确定数据类型。 弱类型： 数据类型可以自动转换。 强类型： 数据类型无法自动转换。 解释型： 边解释，边运行，开发效率更高。 编译型： 编译后运行二进制文件。 脚本： 一般都是可以嵌在其它计算机语言当中执行。   ◆javaScript 的运行环境（解">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="http://example.com/2025/11/24/JavaScript%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="March">
<meta property="og:description" content="JavaScript 是一门动态的，弱类型的，解释型的，基于对象的脚本语言。  动态： 程序执行的时候才会确定数据类型。 静态： 书写代码的时候提前确定数据类型。 弱类型： 数据类型可以自动转换。 强类型： 数据类型无法自动转换。 解释型： 边解释，边运行，开发效率更高。 编译型： 编译后运行二进制文件。 脚本： 一般都是可以嵌在其它计算机语言当中执行。   ◆javaScript 的运行环境（解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post17.jpg">
<meta property="article:published_time" content="2025-11-24T05:16:28.000Z">
<meta property="article:modified_time" content="2026-02-13T12:49:33.507Z">
<meta property="article:author" content="March">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaScript",
  "url": "http://example.com/2025/11/24/JavaScript%E5%9F%BA%E7%A1%80/",
  "image": "http://example.com/img/post17.jpg",
  "datePublished": "2025-11-24T05:16:28.000Z",
  "dateModified": "2026-02-13T12:49:33.507Z",
  "author": [
    {
      "@type": "Person",
      "name": "March",
      "url": "https://github.com/0xMarch-food"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/11/24/JavaScript%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/post17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">March</span></a><a class="nav-page-title" href="/"><span class="site-name">JavaScript</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-24T05:16:28.000Z" title="发表于 2025-11-24 13:16:28">2025-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-13T12:49:33.507Z" title="更新于 2026-02-13 20:49:33">2026-02-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>JavaScript 是一门<strong>动态的</strong>，<strong>弱类型</strong>的，<strong>解释型</strong>的，<strong>基于对象</strong>的<strong>脚本</strong>语言。</p>
<blockquote>
<p><strong>动态：</strong> 程序执行的时候才会确定数据类型。 <strong>静态：</strong> 书写代码的时候提前确定数据类型。</p>
<p><strong>弱类型：</strong> 数据类型可以自动转换。 <strong>强类型：</strong> 数据类型无法自动转换。</p>
<p><strong>解释型：</strong> 边解释，边运行，开发效率更高。 <strong>编译型：</strong> 编译后运行二进制文件。</p>
<p><strong>脚本：</strong> 一般都是可以嵌在其它计算机语言当中执行。</p>
</blockquote>
<p> ◆javaScript 的运行环境（解释器）：</p>
<ol>
<li>浏览器，如Chrome浏览器中的V8引擎。</li>
<li>Node.js。</li>
</ol>
<p>◆浏览器端的 JavaScript 组成部分：</p>
<ol>
<li>基本代码语法， ECMAScript，ECMA指定。</li>
<li>BOM， 浏览器提供的API，W3C指定。</li>
<li>DOM， 文档提供的API，W3C指定。</li>
</ol>
<p>◆其他特点：</p>
<ol>
<li>指令结束符（语句结束符）是分号或者换行。</li>
<li>严格区分大小写。<br><img src="/photo/f9c6643dc2d8b54f2a923c6da720a0ec.jpg"></li>
</ol>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>JavaScript 在 HTML 中使用的三种方式：<br> ① 行内式（内联脚本）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">元素</span> <span class="attr">onclick</span>=<span class="string">&quot;代码..&quot;</span> <span class="attr">ondblclick</span>=<span class="string">&quot;代码..&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">元素</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> ② 内嵌式（嵌入脚本）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>③ 外链式（外部脚本）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js文件的地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>	</span><br></pre></td></tr></table></figure>

<p>JavaScript如何输出内容：<br>① 输出到弹框：alert(内容)。<br>② 输出到页面中：document.write(内容)。<br>③ 输出到控制台：console.log(内容)。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>JS变量名的命名规范：</p>
<ol>
<li>变量名可以由数字、字母、下划线、$ 组成且<strong>不能以数字开头</strong>。</li>
<li>变量名不能是关键字或保留字。</li>
</ol>
<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><code>var</code> 是 JS 早期的变量声明关键字，存在诸多设计缺陷，现在几乎被 <code>let</code>&#x2F;<code>const</code> 完全替代。</p>
<p>◆核心特点：<br>1.<strong>变量提升</strong>：变量声明会被提升到当前作用域顶部，提升后自动初始化为 <code>undefined</code>，可以在声明前使用变量。</p>
<blockquote>
<p>全局代码执行之前会预处理， 查找全局代码中的var关键字，提前创建好变量，不赋值； 当正式执行到变量声明语句的时候，仅仅进行赋值操作。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">//var提升，n为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  n = <span class="number">200</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 200</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>; <span class="comment">// 后声明变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>2.<strong>允许重复声明</strong>：同一作用域内，可以多次用 <code>var</code> 声明同一个变量，不会报错，后续声明会覆盖前面的。<br>3.<strong>无块级作用域</strong>：<mark style="background: #D2B3FFA6;">仅支持全局作用域和函数作用域</mark>，<code>if</code>、<code>for</code>、<code>&#123;&#125;</code> 等块级代码块无法形成独立作用域，变量会泄露到块外。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环经典坑：变量泄露，回调访问全局变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出：5 5 5 5 5（所有回调访问同一个全局 i）</span></span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里还涉及到同步事件与异步事件，后面再学。</p>
</blockquote>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><code>let</code> 是 ES6 为解决 <code>var</code> 的缺陷而新增的关键字，专门用于声明「值会动态变化」的变量。</p>
<p>◆特点：变量值可修改。不存在变量提升。在变量声明之前的区域，变量不可访问。<mark style="background: #D2B3FFA6;">let声明的范围是块作用域</mark>。允许先声明，后赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let：可变变量，块级作用域（只在&#123;&#125;内生效）</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line">age = <span class="number">20</span>; <span class="comment">// 可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">25</span>; <span class="comment">// 局部变量，不影响外部</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b; <span class="comment">//先声明</span></span><br><span class="line">b = <span class="number">10</span>; <span class="comment">//后赋值</span></span><br></pre></td></tr></table></figure>

<p>let也不允许同一个块作用域中出现冗余声明。不过，JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，而这是因为<strong>同一个块中没有重复声明</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name; </span><br><span class="line"><span class="keyword">var</span> name; </span><br><span class="line"><span class="keyword">let</span> age; </span><br><span class="line"><span class="keyword">let</span> age; <span class="comment">// SyntaxError；标识符age已经声明过了</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 30 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">	<span class="keyword">let</span> age = <span class="number">26</span>; </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>◆与var关键字不同，使用let在全局作用域中声明的 变量不会成为window对象的属性（var声明的变量则会）​。<br><img src="/photo/Pasted%20image%2020260207204007.png"></p>
<p>◆条件声明：因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量。</p>
<blockquote>
<p>不要使用“如果某个条件成立，就let 某某”形式来声明变量，一个是因为let没法检查上方是否声明过“某某”这个变量，会报错（实际上在if语句之外也要注意这一点，这是个一般问题），另一个是因为“if(){}”“try{}&#x2F;catch(){}”“typeof”等结束后，这个“某某”就被<strong>销毁</strong>了，对下方代码来说，“某某”跟未定义没有区别。</p>
</blockquote>
<p>◆for循环中的let声明：（包括for-in&#x2F;for-of循环）<br>在使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环<strong>声明一个新的迭代变量</strong>。每个setTimeout引用的都是不同的变量实例，所以console.log输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">0</span>) </span><br><span class="line">	&#125; <span class="comment">// 会输出0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常量，不允许重复声明。<strong>声明时必须同时初始化</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const：常量，声明后不可修改（引用类型内部可改）</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="comment">// PI = 3; // 报错！常量不能重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;小红&quot;</span>; <span class="comment">// 允许！const只锁定引用，不锁定对象内部</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// 小红</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避坑：const声明还必须初始化，let可以先声明后赋值</span></span><br><span class="line"><span class="comment">// const a; // 报错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>“<code>const</code>只锁定引用，不锁定对象内部”这一点类似Java：<code>final</code>关键字对于对象引用，这意味着引用本身不可变（即不能指向另一个对象），但对象的内容仍然可以修改。</p>
</blockquote>
<p>◆关于循环迭代：不能用const来声明迭代变量，因为迭代变量会自增。不过，如果只想用const声明一个不会被修改的for循环变量，那也是可以的。<strong>也就是说，每次迭代只是创建一个新变量。</strong> 比如for-of和for-in循环。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a, b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡声明风格及最佳实践：</p>
<ol>
<li>不使用var。</li>
<li>const优先，let次之。优先使用const来声明变量，只在提前知道未来会有修改时，再使用let。</li>
</ol>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table>
<thead>
<tr>
<th>类型</th>
<th>包含的具体类型</th>
<th>核心特点</th>
</tr>
</thead>
<tbody><tr>
<td>基本数据类型（值类型）</td>
<td>Number、String、Boolean、Null、Undefined、Symbol（ES6 新增）、BigInt（ES6 新增）</td>
<td>1. 存储在<strong>栈内存</strong>中，直接存储值本身。<br>2. 赋值 &#x2F; 传参时，传递的是<strong>值的副本</strong>，修改副本不会影响原数据。<br>3. 类型简单，大小固定。</td>
</tr>
<tr>
<td>引用数据类型（复杂数据类型）</td>
<td>Object（包含子类型：Array、Function、Date、RegExp 等）</td>
<td>1. 值存储在<strong>堆内存</strong>中，栈内存只存储堆内存的地址引用。<br>2. 赋值 &#x2F; 传参时，传递的是<strong>地址引用的副本</strong>，修改新变量会影响原数据。<br>3. 类型复杂，大小不固定，可动态扩展属性 &#x2F; 方法。</td>
</tr>
</tbody></table>
<p><strong>判断数据的类型：<code>typeof(数据)</code></strong>。不加括号可也行，因为typeof是一个操作符而不是函数。</p>
<ul>
<li>调用typeof null返回的是”object”。这是因为特殊值null被认为是一个对空对象的引用。</li>
</ul>
<h2 id="Null-和-undefined"><a href="#Null-和-undefined" class="headerlink" title="Null 和 undefined"></a>Null 和 undefined</h2><p>◆null：Null类型同样只有一个值，即特殊值null。null值表示一个空对象指针，这也是给typeof传一个null会返回”object”的原因。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car);   <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>◆undefiend	：未定义，没有赋值的变量在使用的时候会自动得到undefined。<strong>增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。</strong></p>
<blockquote>
<p>使用typeof操作符时，如果返回undefiend，仅代表该变量当前是否存在，而不能说明该变量一定是undefiend类型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> message;     <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line">    <span class="comment">// 确保没有声明过这个变量</span></span><br><span class="line">    <span class="comment">// let age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> age);      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>二者联系：undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等。用等于操作符比较null和undefined始终返回true。但要注意，这个操作符会为了比较而转换它的操作数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="Boolean-布尔类型"><a href="#Boolean-布尔类型" class="headerlink" title="Boolean 布尔类型"></a>Boolean 布尔类型</h2><p>有两个字面值：<br>true		表示是、肯定、正确<br>false		表示否、否定、错误</p>
<blockquote>
<p>💡注意，布尔值字面量true和false是区分大小写的，因此True和False是有效的标识符，但不是布尔值。</p>
</blockquote>
<p>◆要将一个其他类型的值转换为布尔值，可以调用特定的<code>Boolean()</code>转型函数。<code>Boolean()</code>转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。转换规则如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转化为true的值</th>
<th>转化为false的值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“ “（空字符串）</td>
</tr>
<tr>
<td>Number</td>
<td>非零数值</td>
<td>0，NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>N&#x2F;A（不存在）</td>
<td>undefined</td>
</tr>
</tbody></table>
<p><strong>if等流控制语句会自动执行其他类型值到布尔值的转换。</strong></p>
<h2 id="Number-数值类型"><a href="#Number-数值类型" class="headerlink" title="Number 数值类型"></a>Number 数值类型</h2><p>表示整数和浮点数（小数），JS 不区分整数和浮点型，统一用 Number 表示。</p>
<p>①<strong>浮点数的运算存在精度问题：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>;    <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>
<p>我们日常使用的是十进制（满 10 进 1），而计算机底层只能识别二进制（满 2 进 1）。</p>
<ul>
<li>有些十进制整数或小数，能精确转换为二进制：比如 <code>10</code>（十进制）&#x3D; <code>1010</code>（二进制），<code>0.5</code>（十进制）&#x3D; <code>0.1</code>（二进制）；</li>
<li><strong>但有些十进制小数，无法被二进制精确表示，会变成无限循环的二进制小数</strong>比。如 <code>0.1</code>、<code>0.2</code>，就像十进制无法精确表示 <code>1/3 = 0.333333...</code> 一样。</li>
</ul>
<p> ② <strong>科学计数法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.3e4</span>; 	 <span class="comment">// 13000 （1.3 * 10^4）</span></span><br><span class="line"><span class="number">1.67e78</span>;  <span class="comment">// 1.67 * 10^78</span></span><br><span class="line"><span class="number">2.3e-2</span>   <span class="comment">// 0.023; (2.3 * 10^(-2))</span></span><br></pre></td></tr></table></figure>

<p>③ NaN<br>1.什么是 NaN<br>   NaN，全称 Not a Number，是 number 类型的一种。比如，用0除以0就会得到NaN。、</p>
<blockquote>
<p>如果分子是非0值，分母是有符号0或无符号0，则会返回Infinity或-Infinity。</p>
</blockquote>
<p>2.NaN 的特点<br>   NaN 与任何数字进行任何计算结果都是 NaN。<br>   NaN 与任何数字都不相等，包括自己。</p>
<p>3.isNaN() 函数<br>   把一个值传给<code>isNaN()</code>后，该函数会尝试把它转换为数值。任何不能转换为数值的值都会导致这个函数返回true。</p>
<p>④JavaScript 中数字的有效范围</p>
<ol>
<li>JS 中能表示的最大的数字<code>Number.MAX_VALUE</code>：1.7976931348623157e+308。</li>
<li>JS 中能表示的最小的正数：5e-324。</li>
<li>如果超出有效范围，用 Infinity、-Infinity 表示</li>
<li>函数<code>isFinite()</code>可以判断一个数字是否是有效数字，如果是有效数字结果是true。<br>无效数字： Infinity、-Infinity、NaN。</li>
</ol>
<p>数值转换：Number()、parseInt()、parseFloat()<br>Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。<br>◆Number()函数基于如下规则执行转换。</p>
<ul>
<li>布尔值，true转换为1，false转换为0。</li>
<li>数值，直接返回。</li>
<li>null，返回0。</li>
<li>undefined，返回NaN。</li>
</ul>
<p>◆<code>parseInt()</code>函数更专注于字符串是否包含数值模式。第二个参数用于指定进制数。</p>
<ul>
<li>字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。<blockquote>
<p>这意味着空字符串也会返回NaN（这一点跟Number()不一样，它返回0）​。</p>
</blockquote>
</li>
<li>如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">parseInt</span>(<span class="string">&#x27;123abc&#x27;</span>，<span class="number">10</span>);<span class="comment">//按十进制转换</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>◆<code>parseFloat()</code>，第一次出现的小数点是有效的，但第二次出现的小数点就无效了。比如”22.34.5”将转换成22.34。<code>parseFloat()</code>只解析十进制值，因此不能指定底数。</p>
<h2 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String 字符串类型"></a>String 字符串类型</h2><p><strong>字符串是不可变的。</strong><br>表示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello World&#x27;</span>; <span class="comment">// 单引号 </span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot;JavaScript 数据类型&quot;</span>; <span class="comment">// 双引号 </span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;张三&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">`你好，我是<span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// 反引号（模板字符串，$&#123;&#125; 嵌入变量） </span></span><br><span class="line"><span class="keyword">let</span> str4 = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 空字符串</span></span><br></pre></td></tr></table></figure>
<p>➢为什么字符串不可变还能使用let?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&quot;M&quot;</span>; <span class="comment">// 尝试修改字符串的第0个字符（想把 H 改成 M）</span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出结果：Hello（原字符串完全没变化，说明字符串本身不可变）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看似「修改」字符串的操作，其实是创建了新字符串 </span></span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出：Hello World</span></span><br></pre></td></tr></table></figure>
<p> 转义字符：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\n</span>			换行</span><br><span class="line"><span class="string">\&#x27;</span>			单引号</span><br><span class="line"><span class="string">\&quot;</span>			双引号</span><br><span class="line"><span class="string">\\</span>			转义<span class="string">\本身</span></span><br><span class="line"><span class="string">\uXXXX</span> 		四位十六进制表示unicode字符串</span><br></pre></td></tr></table></figure>

<p>字符串的长度可以通过其length属性获取。<br>转换为字符串：使用几乎所有值都有的toString()方法。null和undefined值没有toString()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>(<span class="number">8</span>)); <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串。<br>字符串插值通过在<code>$&#123;&#125;</code>中使用一个JavaScript表达式实现。<strong>所有插入的值都会使用<code>toString()</code>强制转型为字符串</strong>，而且任何JavaScript表达式都可以用于插值。</p>
<h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><p>广义：一切皆对象，数组、函数都是对象的一种。<br>狭义：Object 数据类型，是对象类型中的一种，与Array、Function 是平级的。</p>
<ol>
<li>Object类型的数据是值的无序集合。</li>
<li>Object类型的数据由属性组成，属性由属性名和属性值组成。</li>
<li>属性值可以是任何类型的数据； 属性名用字符串表示，如果符合标识号规范，可以省略引号。</li>
<li>如果属性的值是一个函数，该属性可以被称为方法</li>
</ol>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>1.直接量方式（最常用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;March&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">getinfo</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`用户名: <span class="subst">$&#123;<span class="variable language_">this</span>.username&#125;</span>, 年龄: <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 验证对象创建成功</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br><span class="line">obj1.<span class="title function_">getinfo</span>(); <span class="comment">// 调用对象方法</span></span><br></pre></td></tr></table></figure>
<p>2.<code>Object()</code>是一个内置函数，传入参数时会将参数转换为对应类型的对象，无参数时返回一个空对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数：返回空对象 </span></span><br><span class="line"><span class="keyword">const</span> obj2_1 = <span class="title class_">Object</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无参数创建空对象：&quot;</span>, obj2_1); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数：将参数转换为对象 </span></span><br><span class="line"><span class="keyword">const</span> obj2_2 = <span class="title class_">Object</span>(<span class="string">&quot;我是字符串&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;传入字符串创建对象：&quot;</span>, obj2_2); <span class="comment">// [String: &#x27;我是字符串&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj2_2 的长度：&quot;</span>, obj2_2.<span class="property">length</span>); <span class="comment">// 5 </span></span><br></pre></td></tr></table></figure>
<p>3.使用<code>new Object()</code>构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;March&quot;</span>;</span><br><span class="line">obj1.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">obj1.<span class="property">getInfo</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`用户名：<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>  年龄：<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">getInfo</span>();  <span class="comment">// 用户名：March  年龄：18</span></span><br></pre></td></tr></table></figure>
<h3 id="对象属性的读写"><a href="#对象属性的读写" class="headerlink" title="对象属性的读写"></a>对象属性的读写</h3><p>1.点号，简洁易用。<br>2.方括号，适合属性名不符合标识符规范、或使用变量表示属性名的场景。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//创建对象</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;March&quot;</span>; <span class="comment">//添加属性和值，使用点号</span></span><br><span class="line">obj1.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">obj1[<span class="string">&#x27;home-address&#x27;</span>] = <span class="string">&quot;四川达州&quot;</span>; <span class="comment">//添加属性和值，使用方括号</span></span><br><span class="line">obj1.<span class="property">getInfo</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`用户名：<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>  年龄：<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1[<span class="string">&#x27;home-address&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>读取不存在的属性，自动得到 undefined。</li>
<li>给不存在的属性赋值，自动添加该属性。</li>
</ol>
</blockquote>
<h3 id="对象属性的遍历"><a href="#对象属性的遍历" class="headerlink" title="对象属性的遍历"></a>对象属性的遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;March&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    [<span class="string">&#x27;homa-address&#x27;</span>]: <span class="string">&quot;四川达州&quot;</span>,</span><br><span class="line">    <span class="attr">getInfo</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`name: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, age: <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>, address: <span class="subst">$&#123;<span class="variable language_">this</span>[<span class="string">&#x27;homa-address&#x27;</span>]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>◆方式 1：<code>for...in</code> 循环（传统方式，遍历可枚举属性，包含继承属性），最常用的对象遍历方式，会遍历对象自身的可枚举属性，以及从原型链继承的可枚举属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历对象的属性prop</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> prop <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prop + <span class="string">&quot;: &quot;</span> + obj1[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hasOwnProperty()：判断属性是否是对象自身的属性（过滤继承属性）</p>
</blockquote>
<p>◆方式 2：<code>Object.keys(对象名)</code>（返回对象自身的可枚举属性名数组，不包含继承属性），<mark style="background: #D2B3FFA6;">返回一个数组</mark>，包含对象自身的所有可枚举属性名（字符串类型），<strong>不包含继承属性和不可枚举属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.keys():返回属性名数组</span></span><br><span class="line"><span class="keyword">let</span> props = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props); <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;homa-address&#x27;, &#x27;getInfo&#x27; ]</span></span><br><span class="line">props.<span class="title function_">forEach</span>( <span class="function"><span class="params">prop</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prop + <span class="string">&quot;: &quot;</span> + obj1[prop]);</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>

<p>◆方式 3：<code>Object.entries()</code>（返回对象自身的可枚举属性键值对数组，不包含继承属性）<br><mark style="background: #D2B3FFA6;">返回一个二维数组</mark>，每个子数组是 <code>[属性名, 属性值]</code>，方便同时获取属性名和属性值。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [ <span class="symbol">&#x27;name</span>&#x27;, <span class="symbol">&#x27;March</span>&#x27; ],</span><br><span class="line">  [ <span class="symbol">&#x27;age</span>&#x27;, <span class="number">18</span> ],</span><br><span class="line">  [ <span class="symbol">&#x27;homa-address</span>&#x27;, <span class="symbol">&#x27;四川达州</span>&#x27; ],</span><br><span class="line">  [ <span class="symbol">&#x27;getInfo</span>&#x27;, [<span class="name">Function:</span> getInfo] ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.entries()：返回键值对数组</span></span><br><span class="line"><span class="keyword">let</span> obj1arr = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj1arr.forEach( item =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(item[0] + &quot;: &quot; + item[1]);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line">obj1arr.<span class="title function_">forEach</span>( <span class="function">(<span class="params">[prop, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prop + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="删除对象中的属性"><a href="#删除对象中的属性" class="headerlink" title="删除对象中的属性"></a>删除对象中的属性</h3><p>使用 <code>delete</code> 运算符可以删除对象的自身属性（无法删除继承属性、不可配置属性），删除成功返回 <code>true</code>，删除失败返回 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deleteprop = <span class="keyword">delete</span> obj1.<span class="property">getInfo</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deleteprop); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br><span class="line"><span class="comment">// obj1.getInfo(); // 报错！不存在该方法。</span></span><br></pre></td></tr></table></figure>
<h3 id="判断对象中是否存在某个属性"><a href="#判断对象中是否存在某个属性" class="headerlink" title="判断对象中是否存在某个属性"></a>判断对象中是否存在某个属性</h3><p>◆方式 1<code>&#39;属性名&#39; in 对象</code>，返回布尔值，存在返回 <code>true</code>，不存在返回 <code>false</code>，会包含从原型链继承的属性。<br>◆方式 2：<code>对象.hasOwnProperty(&#39;属性名&#39;)</code>，返回布尔值，仅判断对象自身的属性，不包含继承属性，更精准。<br>◆方式3：通过判断属性名是否在 <code>Object.keys()</code> 返回的数组中，间接判断属性是否存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj1); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;age&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> props = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props); <span class="comment">// 先获取所有属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="title function_">includes</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h2><ol>
<li>什么是稀疏数组？<br>如果数组中存在没有值的元素，该数组就是稀疏数组。</li>
<li>哪些方式可能会产生稀疏数组？<br>① 给数组添加新元素，索引与前面不连续。<br>② 使用 Array函数或构造函数方式创建数组，只有一个参数且是数字。<br>③ 修改数组的 length 属性，值比原来的大。</li>
</ol>
<p>◆如果数组的元素还是数组，该数组可以称为<strong>多维数组</strong>。</p>
<p>◆字符串具有一部分数组特性，有length属性，可以读取到字符串的长度； 但是length的值不能像数组一样修改。可以通过索引读取到某个字符，但是不能修改单个字符。字符串这种具有一部分数组特性但又不是数组的数据，统称为类数组（伪数组 Like-Array）   </p>
<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>①普通 <code>for</code> 循环<br>②<code>for...in</code> 循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`索引 <span class="subst">$&#123;index&#125;</span>：<span class="subst">$&#123;arr[index]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③<code>forEach</code>（最常用，遍历所有元素，不可中断）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`索引 <span class="subst">$&#123;index&#125;</span>：<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意：return 仅跳过当前次回调，无法中断整个循环</span></span><br><span class="line">  <span class="keyword">if</span> (item === <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无法中断循环（<code>break</code> 报错，<code>continue</code> 无效，<code>return</code> 仅跳过当前次）。</p>
</blockquote>
<p>④数组的内置方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>核心功能</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>map</code></td>
<td>遍历数组，返回一个<strong>新数组</strong>（新数组长度与原数组一致，元素为回调函数返回值）</td>
<td><code>const newArr = arr.map(item =&gt; item * 2);</code></td>
</tr>
<tr>
<td><code>filter</code></td>
<td>遍历数组，返回一个<strong>新数组</strong>（包含所有满足回调函数条件的元素）</td>
<td><code>const newArr = arr.filter(item =&gt; item &gt; 20);</code></td>
</tr>
<tr>
<td><code>find</code></td>
<td>遍历数组，返回<strong>第一个</strong>满足回调函数条件的元素（无满足条件的元素返回 <code>undefined</code>）</td>
<td><code>const target = arr.find(item =&gt; item === 30);</code></td>
</tr>
<tr>
<td><code>findIndex</code></td>
<td>遍历数组，返回<strong>第一个</strong>满足回调函数条件的元素索引（无满足条件的元素返回 <code>-1</code>）</td>
<td><code>const targetIndex = arr.findIndex(item =&gt; item === 30);</code></td>
</tr>
<tr>
<td><code>every</code></td>
<td>遍历数组，判断<strong>所有元素</strong>是否都满足回调函数条件（返回布尔值）</td>
<td><code>const isAllBig = arr.every(item =&gt; item &gt; 0);</code></td>
</tr>
<tr>
<td><code>some</code></td>
<td>遍历数组，判断<strong>是否存在至少一个</strong>元素满足回调函数条件（返回布尔值）</td>
<td><code>const hasBig = arr.some(item =&gt; item &gt; 30);</code></td>
</tr>
</tbody></table>
<h3 id="数组的添加与删除"><a href="#数组的添加与删除" class="headerlink" title="数组的添加与删除"></a>数组的添加与删除</h3><p>① 添加元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 使用 数组.<span class="property">length</span> 作为索引添加元素</span><br><span class="line">   数组[数组.<span class="property">length</span>] = 新元素</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="title function_">push</span>() 方法在数组后面添加一个或多个新元素</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="title function_">unshift</span>() 方法在数组前面添加一个或多个新元素</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="title function_">splice</span>() 方法指定位置添加一个或多个新元素</span><br><span class="line"><span class="comment">// 语法：splice(2, 0, 30)</span></span><br><span class="line"><span class="comment">// 解读：索引 2 开始，删除 0 个元素，插入 30</span></span><br></pre></td></tr></table></figure>

<p>② 删除元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 数组.<span class="property">length</span> -= n;  删除后n个元素</span><br><span class="line"><span class="number">2.</span> 数组.<span class="title function_">pop</span>()		删除最后一个元素，一次只能删除一个</span><br><span class="line"><span class="number">3.</span> 数组.<span class="title function_">shift</span>()	删除第一个元素，一次只能删除一个</span><br><span class="line"><span class="number">4.</span> 数组.<span class="title function_">splice</span>(索引，数量);   删除指定位置指定数量的元素</span><br></pre></td></tr></table></figure>
<h2 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function 函数"></a>Function 函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>① function 关键字方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数列表) &#123;</span><br><span class="line">    语句...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ② <strong>表达式方式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">function</span>（参数列表） &#123;</span><br><span class="line">    语句...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>◆关于return：</p>
<ul>
<li>当函数遇到return后，函数会立即停止执行并推出，因此return语句后面的代码不会执行。</li>
<li>return语句也可以不带返回值。这时候，函数会立即停止执行并返回undefined。这种用法最常用于提前终止函数执行，并不是为了返回值。</li>
</ul>
<h3 id="函数形参与实参"><a href="#函数形参与实参" class="headerlink" title="函数形参与实参"></a>函数形参与实参</h3><p>无默认值的参数是必传（调用时必须传入对应值，否则为 <code>undefined</code>），带默认值的参数是可选的，<strong>可选参数放在必选参数后面</strong>，符合正常的调用逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有默认值参数放在末尾</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name, greeting = <span class="string">&quot;你好&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>，<span class="subst">$&#123;name&#125;</span>！`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用场景1：传入所有参数（覆盖默认值）</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;早上好&quot;</span>); <span class="comment">// 早上好，张三！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用场景2：只传入必选参数（默认值生效）</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&quot;李四&quot;</span>); <span class="comment">// 你好，李四！</span></span><br></pre></td></tr></table></figure>

<p>◆形参和实参的数量问题：</p>
<ol>
<li>如果实参数量&gt;形参数量，实参按照顺序给形参赋值，多出的实参没有作用。</li>
<li>如果实参数量&lt;形参数量，实参按照顺序给形参赋值，后面的形参没有被赋值，使用的时候自动undefined。</li>
</ol>
<p>◆arguments</p>
<ol>
<li>arguments 是系统创建的变量，只能在函数中使用。</li>
<li>arguments 的值是一个伪数组，由调用函数时所传递的实参组成。</li>
<li>可以使用 arguments 实现可变参数数量的函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建函数 该函数计算所有参数的和</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义变量 记录和</span></span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历所有的参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i ++) &#123;</span><br><span class="line">        res += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回计算结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数内的形参、argument 都是局部变量。</p>
</blockquote>
<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><ol>
<li>全局代码执行之前会预处理， 查找全局代码中的function关键字，提前创建好变量并赋值完整函数体； 当正式执行到函数声明语句的时候，直接跳过。</li>
<li>函数调用的时候，执行函数体语句前也会预处理， 查找函数代码中的function关键字，提前创建好变量并赋值； 当正式执行到函数声明语句的时候，直接跳过。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1. 函数内执行前访问 funcVar：&quot;</span>, funcVar);</span><br><span class="line">  <span class="keyword">var</span> funcVar = <span class="string">&quot;我是函数内变量&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2. 函数内赋值后访问 funcVar：&quot;</span>, funcVar); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testFunc</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\n3. 函数外部访问 funcVar：&quot;</span>, <span class="keyword">typeof</span> funcVar); </span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<ol>
<li>函数内执行前访问 funcVar： undefined</li>
<li>函数内赋值后访问 funcVar： 我是函数内变量</li>
<li>函数外部访问 funcVar： undefined</li>
</ol>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>匿名函数</strong>就是没有名字的函数，匿名函数适合用于立即调用的函数和回调函数。</p>
<p>满足以下三个条件的函数就是回调函数：<br>1）函数是我定义的。<br>2）我没有调用（没有直接调用）。<br>3）函数最终执行了。</p>
<p>回调函数的使用场景：</p>
<ol>
<li>数组的一些方法需要回调函数当参数，如 forEach、sort、filter、map、reduce 等等</li>
<li>定时器的回调函数</li>
<li>DOM事件的回调函数</li>
<li>Ajax 的回调函数</li>
<li>Promise 的回调函数<br>…<blockquote>
<p>大部分回调函数的形式都是作为其他函数的参数！</p>
</blockquote>
</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>它是一个特殊的函数，专门用于<strong>批量创建具有相同结构和方法的对象</strong>，相当于对象的模板。每个对象都有对应的构造函数，不同数据类型的对象，构造函数不同。</p>
<ul>
<li>数组对象 → 构造函数 <code>Array</code></li>
<li>函数对象 → 构造函数 <code>Function</code></li>
<li>普通对象 → 构造函数 <code>Object</code></li>
<li>字符串对象 → 构造函数 <code>String</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 =&#123;<span class="attr">name</span>:<span class="string">&quot;March&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">constructor</span>); <span class="comment">// [Function: Object]</span></span><br></pre></td></tr></table></figure>

<p><strong>◆构造函数与对象之间的关系</strong></p>
<ol>
<li>构造函数是模板。描述了对象的<strong>共同结构</strong>（有哪些属性、哪些方法）。</li>
<li>对象是构造函数的实例。是根据模板创建出来的<strong>具体对象</strong>，每个实例都拥有模板描述的属性和方法。</li>
</ol>
<p><strong>◆判断对象的构造函数</strong></p>
<ol>
<li><code>instanceof</code> 运算符，对象是否是某个构造函数的实例。</li>
<li><code>constructor</code> 属性，直接获取对象的构造函数。</li>
</ol>
<p>◆<strong>实例化（创建对象的过程）</strong><br>用 <code>new</code> 关键字调用构造函数，<strong>创建对象实例的过程</strong>，就叫实例化。new 构造函数(参数)。</p>
<ul>
<li><code>&#123;&#125;</code> → 等价于 <code>new Object()</code>。</li>
<li><code>[]</code> → 等价于 <code>new Array()</code>。</li>
<li><code>&#39;hello&#39;</code> → 等价于 <code>new String(&#39;hello&#39;)</code>。<br>每实例化一次，就会创建一个全新的对象，每个对象都有独立的内存空间，互不影响。</li>
</ul>
<p>◆<strong>自定义构造函数</strong><br>规则：</p>
<ul>
<li>构造函数名<strong>首字母大写</strong>（约定俗成，区分普通函数）。</li>
<li>函数内部用 <code>this</code> 关键字，指向即将被创建的对象实例，给 <code>this</code> 添加属性和方法，就是给实例添加属性和方法。</li>
<li><strong>必须用 <code>new</code> 关键字调用</strong>，否则 <code>this</code> 会指向全局（浏览器中是 <code>window</code>）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age, address</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>[<span class="string">&#x27;home-address&#x27;</span>] = address;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">buy</span> = <span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 买了一件商品:<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;March&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;四川达州&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user1);</span><br><span class="line">user1.<span class="title function_">buy</span>(<span class="string">&#x27;ViVO X100s Pro&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>◆<strong>原始类型数据的对象特性</strong><br>1.原始类型（Number、String、Boolean）的两种状态。</p>
<ul>
<li><strong>值状态</strong>：直接量创建（如 <code>var num = 10;</code>），存储的是原始值，占用内存小，是默认状态。</li>
<li><strong>对象状态（包装对象）</strong>：用 <code>new</code> 关键字创建（如 <code>var numObj = new Number(10);</code>），存储的是对象，占用内存大，拥有构造函数的原型方法（如 <code>toString()</code>、<code>length</code>）。<br>2.<strong>自动转换（隐式包装）</strong>。</li>
<li><mark style="background: #D2B3FFA6;">当对值状态的原始类型调用对象方法（如 <code>num.toString()</code>）时，JavaScript 会自动将其包装为对象状态，执行方法后再销毁包装对象，恢复为值状态。</mark>这就是为什么原始值可以调用对象方法（如 <code>&#39;hello&#39;.length</code>），我们无需手动创建包装对象。</li>
</ul>
<h2 id="Date-日期"><a href="#Date-日期" class="headerlink" title="Date 日期"></a>Date 日期</h2><p>要创建日期对象，就使用new操作符来调用Date构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
<p>在不给Date构造函数传参数的情况下，创建的对象将保存当前日期和时间。</p>
<p>要基于其他日期和时间创建日期对象，必须传入其毫秒表示。ECMAScript为此提供了两个辅助方法：Date.parse()和Date.UTC()。</p>
<p>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。</p>
<h1 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h1><p>在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。<br>1.保存原始值的变量是<strong>按值访问的</strong>，因为我们操作的就是存储在变量中的实际值。<br>2.<strong>引用值是保存在内存中的对象</strong>。对于引用值而言，可以随时添加、修改和删除其属性和方法。</p>
<blockquote>
<p>💡注意，原始类型的初始化可以只使用原始字面量形式。<strong>如果使用的是new关键字，则JavaScript会创建一个Object类型的实例</strong>，但其行为类似原始值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">    name1.<span class="property">age</span> = <span class="number">27</span>;</span><br><span class="line">    name2.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name1.<span class="property">age</span>);     <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name2.<span class="property">age</span>);     <span class="comment">// 26</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name1); <span class="comment">// string</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>◆复制值：除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。<br>1.在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。它们<strong>独立使用，互不干扰</strong>。<br>2.在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。<strong>区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象</strong>。操作完成后，两个变量实际上指向同一个对象，<strong>因此一个对象上面的变化会在另一个对象上反映出来</strong>。</p>
<p>◆传递参数：ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) &#123;</span><br><span class="line">      num += <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title function_">addTen</span>(count);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);   <span class="comment">// 20，没有变化</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>💡如果num是按引用传递的，那么count的值也会被修改为30。</p>
</blockquote>
<p>◆关于栈内存堆内存<br><strong>引用类型参数的值是栈内存里面的「堆内存地址」，这是容易混淆的核心</strong>。<br>图源：March<br><img src="/photo/Drawing%202026-02-07%2012.48.32.excalidraw.png"><br>下面这个例子，如果person是按引用传递的，那么person应该自动将指针改为指向name为”marchfood”的对象。<br>‼️实际情况：当我们再次访问<code>person.name</code>时，它的值是 “March” ，这表明函数中参数的值改变之后，原始的引用仍然没变。当你执行 <code>obj = new Object()</code> 时，obj 就抛弃了原来的副本地址，转而指向函数内部新建的一个临时对象；这个临时对象只存在于函数执行的过程中，函数执行完后，JavaScript 垃圾回收机制会把它销毁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">      obj.<span class="property">name</span> = <span class="string">&quot;March&quot;</span>;</span><br><span class="line">      obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">      obj.<span class="property">name</span>=<span class="string">&quot;marchfood&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="title function_">setName</span>(person);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);   <span class="comment">// &quot;March&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>而之前修改的堆对象并不会消失，外部 <code>person</code> 依然牢牢指向它，这就是为什么 <code>name</code> 还是 <code>March</code>，而不是 <code>undefined</code>。</p>
</blockquote>
<h1 id="确定类型"><a href="#确定类型" class="headerlink" title="确定类型"></a>确定类型</h1><p>前面学过typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回”object”。</p>
<p>typeof虽然对原始值很有用，但它对引用值的用处不大。<strong>我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Object</span>);   <span class="comment">// 变量person是Object吗？</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(colors <span class="keyword">instanceof</span> <span class="title class_">Array</span>);    <span class="comment">// 变量colors是Array吗？</span></span><br></pre></td></tr></table></figure>
<p>如果用instanceof检测原始值，则始终会返回false，因为原始值不是对象。</p>
<blockquote>
<p>第二个操作数是对象原型链上的某个对象的构造函数也成立。</p>
</blockquote>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。通过<strong>自动内存管理</strong>实现内存分配和闲置资源回收。</p>
<p>基本思路很简单：<mark style="background: #D2B3FFA6;">确定哪个变量不会再使用，然后释放它占用的内存。</mark>这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动运行。</p>
<p>垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p>
<p>比如，函数。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。</p>
<p>垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量有不同的实现方式。在浏览器的发展史上，用到过两种主要的标记策略：<strong>标记清理</strong>和<strong>引用计数</strong>。</p>
<p>◆<strong>标记清理</strong><br>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）​。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。</p>
<p>◆<strong>引用计数</strong><br>其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p>
<blockquote>
<p>这种策略很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。</p>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>&#x3D;&#x3D;&#x3D; 操作数的类型和值都相等才是true。（首选）<br>&#x3D;&#x3D; 先尝试将两个操作数转换成相同类型，然后进行值比较。</p>
<p>转换规则：</p>
<ul>
<li>数字和字符串比较：字符串转换成数字，再比较。</li>
<li>布尔值和其他类型比较：布尔值转换成数字（<code>true → 1</code>，<code>false → 0</code>），再比较。</li>
<li><code>null</code> 和 <code>undefined</code> 比较：返回 <code>true</code>（彼此相等，且不等于其他任何值）。</li>
</ul>
<p>关于自增自减：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n ++ &amp;&amp; n --);  <span class="comment">//101</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);             <span class="comment">//100 </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-- n || n ++);  <span class="comment">//100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);             <span class="comment">//99</span></span><br></pre></td></tr></table></figure>
<h1 id="常见语句"><a href="#常见语句" class="headerlink" title="常见语句"></a>常见语句</h1><p>if同c语言<br>for同c语言<br>switch同c语言:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值: 语句...; <span class="keyword">break</span>;        </span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值: 语句...; <span class="keyword">break</span>;     </span><br><span class="line">	<span class="keyword">case</span> 表达式可能的值: 语句...; <span class="keyword">break</span>;     </span><br><span class="line">	<span class="keyword">case</span> 表达式可能的值: 语句...; <span class="keyword">break</span>;     </span><br><span class="line">    <span class="attr">default</span>: 语句...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关键字-this"><a href="#关键字-this" class="headerlink" title="关键字 this"></a>关键字 this</h1><ol>
<li>在函数外面使用（全局下使用）：<mark style="background: #D2B3FFA6;">Node.js 中全局对象是 globalThis，浏览器中是 window</mark>。</li>
<li>在构造函数内部使用：this 的值是构造函数的实例（实例化构造函数所创建的对象）。</li>
<li>在函数（方法）中使用：this 的值是调用该函数（方法）的对象。<br>注意：不要看函数声明语句所在的地方，看调用函数的语句，看.前面是哪个对象。</li>
</ol>
<p>关于window:</p>
<ol>
<li>window 表示浏览器窗口， 运行在浏览器上的js，window 作为全局对象。</li>
<li>在打开浏览器的时候 window 对象就自动创建了。</li>
<li>所有的全局变量都是 window 的属性， 使用 window 的属性可以省略 window。</li>
</ol>
<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型的概念与特点"><a href="#原型的概念与特点" class="headerlink" title="原型的概念与特点"></a>原型的概念与特点</h3><p><mark style="background: #D2B3FFA6;">每个函数都会创建一个prototype属性，这个属性是一个Object对象，包含应该由特定引用类型的实例共享的属性和方法。</mark>实际上，这个对象就是通过调用构造函数创建的对象的<strong>原型</strong>。原型本身也是普通对象，对象可以直接借用原型上的属性 &#x2F; 方法（这个过程叫<strong>原型继承</strong>）。</p>
<p>◆原型特点：</p>
<ol>
<li>每个对象都有原型。</li>
<li>原型也是对象。</li>
<li>对象可继承原型属性。</li>
</ol>
<p><strong>使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line">    <span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>分析：这里，所有属性和sayName()方法都直接添加到了Person的prototype属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此person1和person2访问的都是相同的属性和相同的sayName()函数。</p>
<h3 id="如何获取对象的原型？"><a href="#如何获取对象的原型？" class="headerlink" title="如何获取对象的原型？"></a>如何获取对象的原型？</h3><ol>
<li>隐式：通过对象获取原型。</li>
<li>显式：通过对象的构造函数获取原型。</li>
<li>使用Object的方法。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: &#x27;Nicholas&#x27;,</span></span><br><span class="line"><span class="comment">//   age: 29,</span></span><br><span class="line"><span class="comment">//   job: &#x27;Software Engineer&#x27;,</span></span><br><span class="line"><span class="comment">//   sayName: [Function (anonymous)]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">//[Function: Person]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，所有原型对象自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数。</p>
</blockquote>
<h3 id="对象、构造函数、原型之间的关系"><a href="#对象、构造函数、原型之间的关系" class="headerlink" title="对象、构造函数、原型之间的关系"></a>对象、构造函数、原型之间的关系</h3><p>① 对象和构造函数</p>
<ol>
<li>构造函数是对象的描述，对象是构造函数的实例。</li>
<li>一个构造函数可以有无数个对象，一个对象只能有一个构造函数。</li>
</ol>
<p>② 对象和原型</p>
<ol>
<li>每个对象都有原型，可以使用原型上的属性。</li>
<li>一个对象只能有一个原型，一个原型可以作为多个对象的原型。</li>
</ol>
<p>③ 构造函数和原型</p>
<ol>
<li>可以通过构造函数获取到对象的原型。</li>
<li>构造函数相同的对象，原型也是相同的； <strong>相同数据类型的原型，原型相同。</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同数组</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> arr3 = []; <span class="comment">// 空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型是否相同</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(arr1) === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(arr2)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(arr1) === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(arr3)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(arr1) === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true（最终都指向 Array.prototype）</span></span><br></pre></td></tr></table></figure>

<p>◆判断属性是否属于对象本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;属性名&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>只有属性在对象本身上才返回true，否则都是false（即使在原型不在本身也是false）。</p>
<h3 id="创建对象的同时设置原型"><a href="#创建对象的同时设置原型" class="headerlink" title="创建对象的同时设置原型"></a>创建对象的同时设置原型</h3><p>1.<code>var obj1 = &#123;&#125;</code>：是创建普通对象的字面量语法，默认原型是 <code>Object.prototype</code>（JavaScript 所有普通对象的默认原型）；<br>2.<code>Object.create(proto)</code>：ES5 提供的自定义原型创建对象的方法，核心作用是：</p>
<ul>
<li>创建一个<strong>空对象</strong>（自身无任何属性）；</li>
<li>将这个空对象的 <code>[[Prototype]]</code>（原型）<strong>强制设置为传入的 <code>proto</code> 参数</strong>；</li>
<li>如果 <code>proto</code> 是 <code>null</code>，则创建无原型的纯净对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象 原型是提取准备好的 实例化的时候将对象与原型关联</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象的同时 自己设置原型</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象的同时 自己设置原型</span></span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>);<span class="comment">//最终：obj3自身空，继承字符串对象的所有属性或方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建没有原型的对象</span></span><br><span class="line"><span class="keyword">var</span> obj4 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj4);</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个对象都有原型，原型还是个对象，原型也有原型，原型的原型也有原型，组成了原型链。原型链终点是<code>Object.prototype</code>，其<code>__proto__</code>为null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//arr1.__proto__ === Array.prototype</span></span><br><span class="line"><span class="comment">//arr1.__proto__.__proto__ === Object.prototype</span></span><br></pre></td></tr></table></figure>

<p>◆作用：</p>
<ol>
<li>对象在查找找属性的时候，先从自身去找看有没有这个属性，如果有，直接使用这个属性的值。</li>
<li>如果没有，会沿着原型链向上找，如果找到就使用这个属性的值且停止查找，如果没找到继续向上找直到原型链的终点。</li>
<li>如果找到原型链的终点还没有找到，就返回 undefined 。</li>
</ol>
<h2 id="题目思考"><a href="#题目思考" class="headerlink" title="题目思考"></a>题目思考</h2><ol>
<li>下面代码中的对象 f 有方法 a 和方法 b 吗？</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>实例 f 的原型链（普通对象）f → F.prototype → Object.prototype → null</li>
<li>函数 F 的原型链（函数对象）F → Function.prototype → Object.prototype → null</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>绝对值：Math.abs()<br>平方：Math.pow()<br>toString() 转化为字符串</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/0xMarch-food">March</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/11/24/JavaScript%E5%9F%BA%E7%A1%80/">http://example.com/2025/11/24/JavaScript%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">March</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div><div class="post-share"><div class="social-share" data-image="/img/post17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/05/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="密码学"><img class="cover" src="/img/post12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">密码学</div></div><div class="info-2"><div class="info-item-1">基础概念研究信息加密和解密方法的科学与技术统称为密码学，是研究信息保密与破译的基本规律为对象的学科。 ◆经典密码学：密码分析学、密码编码学。◆现代密码学：密码分析学、密码编码学、密钥管理学。 经典密码学主要以实现信息的保密性为目的，现代密码学不仅可以实现信息的保密性，而且还可以实现信息的真实性、完整性、可用性、可审查性和可靠性等。 现代密码学最重要的原则是“一切秘密寓于密钥之中”。即算法是公开的，但密钥必须是保密的。当加密完成后，可以将密文通过不安全的渠道发送给收信人，只有拥有密钥的收信人才可以对密文进行解密（即反变换得到明文）。 保密通信模型:香农 -&gt; 概率统计观点 -&gt; 通信系统 12信源-&gt;编码器-&gt;信道-&gt;解码器-&gt;接收者干扰源-&gt;信道 保密通信系统：（不赘述）  在私钥密码体制和公钥密码体制下，保密通信模型的差别主要体现在加密密钥的分发或传递上。私钥密码体制下，接收方和发送方的共享密钥必须通过安全信道传递。而在公钥密码体制下，发送方只需要认证所使用的加密密钥是接收方的。  柯克霍夫原则：密码分析者-&gt;密码算法-x-&gt...</div></div></div></a><a class="pagination-related" href="/2025/11/24/Java/" title="Java"><img class="cover" src="/img/post2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java</div></div><div class="info-2"><div class="info-item-1">开始项目里面放模块，模块里放包。main方法快捷键 psvm+enter:  12public static void main(String[] args) &#123; &#125; 控制台原样输出 sout+enter: 1System.out.println(); ctrl+y:删除一行ctrl+d:复制一行注释：单行//，多行/*+enter 文档注释 无论主方法main在哪个类里，只要文件中存在public类，文件名就由那个类决定。 Java概述诞生：Java是1995年6月由Sun公司引进到我们这个世界的革命性的编程语言。1990年Sun公司成立了由James Gosling领导的开发小组，开始致力于开发一种可移植的、跨平台的语言Java。 Java，一门很好的面向对象语言，其平台无关性让Java成为编写网络应用程序的佼佼者，而且Java也提供了许多以网络应用为核心的技术，使得Java特别适合于网络应用软件的设计与开发。  Java特点：简单、面向对象、平台无关、多线程、动态。   简单：C++需要手动管理内存，而Java采用自动垃圾回收机制。 面向对象：通过封装数...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/25/%E5%89%8D%E7%AB%AFJavaScript/" title="前端JavaScript"><img class="cover" src="/img/post3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-25</div><div class="info-item-2">前端JavaScript</div></div><div class="info-2"><div class="info-item-1">JavaScript 是脚本语言，实现人机互动。JS权威网站：MDN Web Docs作用：网页特效、表单验证、数据交互、服务端编程 开始前端JS &#x3D; 语法基础 + Web APIsJS书写位置：  内部 外部（外部JS标签中间不要写代码，会被忽略）  1&lt;script src=&quot;./alert.js&quot;&gt;&lt;/script&gt;  内联  1&lt;button onclick=&quot;alert(&#x27;骗你的&#x27;)&quot;&gt;点击我月薪过万&lt;/button&gt; JS末尾分号可写可不写注释：//单行注释与  /*多行注释内容*/ 输入输出 输出语句（1）  1document.write(&#x27;内容&#x27;) 作用：向body内输出内容注意：即使有标签，也会被解析（2） 1alert(&#x27;内容‘) 作用：页面弹出警告对话框（3） 1console.log(&#x27;内容&#x27;) 作用：控制台输出语法，调试使用  输入语句  1prompt(&#x27;请输入您的学号：&#...</div></div></div></a><a class="pagination-related" href="/2025/10/23/%E5%89%8D%E7%AB%AF-%E5%9B%9E%E5%A3%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/" title="前端-回声每周任务总结"><img class="cover" src="/img/post7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">前端-回声每周任务总结</div></div><div class="info-2"><div class="info-item-1">Week2（基础表单+鱼）需加强的点 &lt;label&gt;  标签的  for  属性需要与对应表单元素的  id  属性值匹配才能建立关联，否则点击文字不会触发单选按钮的选中状态。 对于单选按钮（type=&quot;radio&quot;），需要给同一组选项设置相同的  name  属性（如name=&quot;gender&quot;），这样它们才能选了一个就不能选另一个。 下拉框选择：  12345&lt;label for=&quot;direction&quot;&gt;选择方向：&lt;/label&gt;&lt;select id=&quot;direction&quot; name=&quot;direction&quot;&gt;  &lt;option value=&quot;web-frontend&quot;&gt;Web 前端组&lt;/option&gt;  &lt;option value=&quot;web-backend&quot;&gt;Web 后端组&lt;/option&gt;&lt;/select&gt;&lt;br /&gt; ...</div></div></div></a><a class="pagination-related" href="/2026/02/13/HTML+CSS/" title="HTML+CSS"><img class="cover" src="/img/post16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-13</div><div class="info-item-2">HTML+CSS</div></div><div class="info-2"><div class="info-item-1">开始开发工具：VsCodectrl + z 撤销ctrl + s 保存alt + shift + f 代码自动格式化Emmet快捷键： https://docs.emmet.io/abbreviations/syntax/在本地开发，在服务器共享。 HTML5W3C 官网：  https://html.spec.whatwg.org/multipage/MDN: https://developer.mozilla.org/zh-CN/docs/Web/HTML 基础标签排版标签   标签名 语义和功能 单标签还是双标签    h1 ~ h6 一级标题~六级标题 双标签   p 段落 双标签   hr 分隔线 单标签   br 换行 单标签   pre 原格式显示 双标签   div 无语义，用于页面布局 双标签   文本标签   标签名 语义和功能 单标签还是双标签    ins 表示增加的内容，默认添加下划线 双标签   del 表示删除的内容，默认添加删除线 双标签   sub 下标字 双标签   sup 上标字 双标签   em 强调，默认表现斜体字 双标签   stron...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">March</div><div class="author-info-description">Major in BlackChain | Web3 learner</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0xMarch-food"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这里是对自己一些学习内容的记录，欢迎探讨指正！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var"><span class="toc-number">2.1.</span> <span class="toc-text">var</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let"><span class="toc-number">2.2.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">2.3.</span> <span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Null-%E5%92%8C-undefined"><span class="toc-number">3.1.</span> <span class="toc-text">Null 和 undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boolean-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Boolean 布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">Number 数值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">String 字符串类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.</span> <span class="toc-text">Object 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">3.5.2.</span> <span class="toc-text">对象属性的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.5.3.</span> <span class="toc-text">对象属性的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.5.4.</span> <span class="toc-text">删除对象中的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-number">3.5.5.</span> <span class="toc-text">判断对象中是否存在某个属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array%E6%95%B0%E7%BB%84"><span class="toc-number">3.6.</span> <span class="toc-text">Array数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.1.</span> <span class="toc-text">数组的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%BB%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">3.6.2.</span> <span class="toc-text">数组的添加与删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">Function 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.1.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="toc-number">3.7.2.</span> <span class="toc-text">函数形参与实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">3.7.3.</span> <span class="toc-text">函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.4.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.5.</span> <span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date-%E6%97%A5%E6%9C%9F"><span class="toc-number">3.8.</span> <span class="toc-text">Date 日期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">原始值与引用值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">确定类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.</span> <span class="toc-text">常见语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-this"><span class="toc-number">9.</span> <span class="toc-text">关键字 this</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">10.</span> <span class="toc-text">原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">10.1.</span> <span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">10.1.1.</span> <span class="toc-text">原型的概念与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%EF%BC%9F"><span class="toc-number">10.1.2.</span> <span class="toc-text">如何获取对象的原型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">10.1.3.</span> <span class="toc-text">对象、构造函数、原型之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%9E%8B"><span class="toc-number">10.1.4.</span> <span class="toc-text">创建对象的同时设置原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">10.2.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83"><span class="toc-number">10.3.</span> <span class="toc-text">题目思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">11.</span> <span class="toc-text">其他</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/17/Solidity/" title="Solidity">Solidity</a><time datetime="2026-02-13T12:50:34.559Z" title="更新于 2026-02-13 20:50:34">2026-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/24/JavaScript%E5%9F%BA%E7%A1%80/" title="JavaScript">JavaScript</a><time datetime="2026-02-13T12:49:33.507Z" title="更新于 2026-02-13 20:49:33">2026-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/13/HTML+CSS/" title="HTML+CSS">HTML+CSS</a><time datetime="2026-02-13T12:41:36.098Z" title="更新于 2026-02-13 20:41:36">2026-02-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/post17.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By March</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>