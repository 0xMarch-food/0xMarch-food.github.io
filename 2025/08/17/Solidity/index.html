<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Solidity | March</title><meta name="author" content="March"><meta name="copyright" content="March"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习网站：Solidity 官方文档WTF 学院 代码框架123456&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MyContract &#123;&#125; 第一行是SPDX许可证标识，用于声明该合约使用 MIT 开源许可证。在 Solidity 0.6.8 及以上版本中，推荐显式声明许可证，它告诉用户该合约的使">
<meta property="og:type" content="article">
<meta property="og:title" content="Solidity">
<meta property="og:url" content="http://example.com/2025/08/17/Solidity/index.html">
<meta property="og:site_name" content="March">
<meta property="og:description" content="学习网站：Solidity 官方文档WTF 学院 代码框架123456&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MyContract &#123;&#125; 第一行是SPDX许可证标识，用于声明该合约使用 MIT 开源许可证。在 Solidity 0.6.8 及以上版本中，推荐显式声明许可证，它告诉用户该合约的使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post1.jpg">
<meta property="article:published_time" content="2025-08-17T15:33:42.000Z">
<meta property="article:modified_time" content="2025-11-27T14:45:12.815Z">
<meta property="article:author" content="March">
<meta property="article:tag" content="Web3核心">
<meta property="article:tag" content="智能合约">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Solidity",
  "url": "http://example.com/2025/08/17/Solidity/",
  "image": "http://example.com/img/post1.jpg",
  "datePublished": "2025-08-17T15:33:42.000Z",
  "dateModified": "2025-11-27T14:45:12.815Z",
  "author": [
    {
      "@type": "Person",
      "name": "March",
      "url": "https://github.com/0xMarch-food"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/08/17/Solidity/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Solidity',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/post1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">March</span></a><a class="nav-page-title" href="/"><span class="site-name">Solidity</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Solidity</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-17T15:33:42.000Z" title="发表于 2025-08-17 23:33:42">2025-08-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-27T14:45:12.815Z" title="更新于 2025-11-27 22:45:12">2025-11-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>学习网站：<br><a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/v0.8.30/">Solidity 官方文档</a><br><a target="_blank" rel="noopener" href="https://www.wtf.academy/en/course">WTF 学院</a></p>
<h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行是SPDX许可证标识，用于声明该合约使用 MIT 开源许可证。在 Solidity 0.6.8 及以上版本中，推荐显式声明许可证，它告诉用户该合约的使用权限和限制。<br>第二行<code>pragma</code>是 Solidity 中的关键字，用于指定编译器版本规则。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>在任何一个Solidity智能合约中，首先需要的就是Solidity的使用版本，它应该被标注在Solidity代码的最上面。</p>
<blockquote>
<p>Solidity是一个更新频率很高的语言，和别的语言相比，它总会有新版本，所以我们需要告诉代码，要用哪个版本。</p>
</blockquote>
<ul>
<li>^0.8.0（最常见的形式）：表示支持0.8.0及以上的版本（同 &gt;&#x3D; 0.8.0）。</li>
<li>0.8.22：表示只支持0.8.22版本。</li>
<li>&#x3D; 0.8.0 &lt;&#x3D; 0.9.0：表示支持0.8.0及以上0.9.0及以下的版本。</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Solidity 合约可以使用一种特殊形式的注释来提供丰富的函数、返回变量等的文档。这种特殊形式是 命名为以太坊自然语言规范格式（NatSpec）。<br>![[photo&#x2F;Pasted image 20251018174621.png]]</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>值类型 + 引用类型</p>
<ol>
<li>值类型<ul>
<li>布尔类型（bool）：布尔类型表示真或假的值。</li>
<li>整数类型：整数类型分为有符号和无符号两种。<br> （有符号整数类型包括int8、int16、int32、int64等。）<br> （无符号整数类型包括uint8、uint16、uint32、uint64等。）</li>
<li>地址类型（address）：地址类型表示以太坊网络上的账户地址。</li>
<li>定长字节类型（bytes）：字节类型表示一组字节数据。（例如，bytes32表示32个字节的数据，一个字节由两个16进制表示）例如，<code>bytes32 data;</code> 可以存储32字节的数据，常用于存储哈希值等。</li>
<li>枚举类型（enum）：自定义的枚举类型可以用来定义一组具名的常量值。</li>
</ul>
</li>
<li>引用类型<ul>
<li>动态大小字节数组（bytes和string）</li>
<li>字节数组（bytes）：动态长度的字节数组，用于存储字节数据。例如，<code>bytes myData;</code> 声明了一个动态字节数组，可以根据需要存储不同长度的字节数据。</li>
<li>字符串（string）：用于存储字符序列，本质上是一个特殊的动态字节数组。例如，<code>string myString;</code>可以存储文本信息。</li>
<li>数组可以是固定长度也可以是动态长度。例如，<code>uint[] public myArray;</code>声明了一个动态长度的无符号整数数组。数组元素可以通过索引访问，如<code>myArray[0]</code>访问第一个元素。</li>
<li>映射（Mapping）：一种”键 - 值”对的数据存储结构。例如，<code>mapping(address =&gt; uint) public balances;</code>创建了一个将 address 类型映射到 uint 类型的映射，用于存储账户余额，通过 <code>balances[address]</code>来获取或设置特定账户的余额。</li>
</ul>
</li>
</ol>
<h2 id="数据类型的默认值"><a href="#数据类型的默认值" class="headerlink" title="数据类型的默认值"></a>数据类型的默认值</h2><p>在 Solidity 中，变量和状态变量都有默认值。这些默认值取决于变量的类型。</p>
<ul>
<li><p>bool类型的默认值是 false。</p>
</li>
<li><p>整数类型（包括 uint 和 int）的默认值是0。</p>
</li>
<li><p>地址类型（address）的默认值是0x0000000000000000000000000000000000000000或 <code>address(0)</code>。</p>
</li>
<li><p>字符串类型（string）：空字符串。</p>
</li>
<li><p>动态数组（包括字符串数组）和映射的默认值是一个空的、长度为0的集合。</p>
</li>
<li><p>对于结构体和枚举类型，默认值是其成员变量类型的默认值。     </p>
</li>
<li><p>enum的默认值是枚举中的第一个元素。</p>
</li>
</ul>
<blockquote>
<p><code>delete a</code>会让变量<code>a</code>的值变为初始值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// delete操作符</span><br><span class="line">bool public _bool2 = true; </span><br><span class="line">function d() external &#123;</span><br><span class="line">    delete _bool2; // delete会让_bool2变为默认值，false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a>1. 状态变量</h3><p>存在链上，所有合约内函数均可访问，耗 gas 多，在合约内、函数外声明，可以在函数里更改值</p>
<h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>仅在函数中有效的变量，存在内存里，不上链，gas 低</p>
<h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>都是 solidity 预留关键字，不用声明，在函数内直接用，具体看 <a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">官方文档</a>，常用的有如下几个：</p>
<ul>
<li><code>msg.sender</code> (<code>address</code>)：消息的发送者（当前调用）</li>
<li><code>tx.origin</code> (<code>address</code>)：交易的发送者</li>
<li><code>msg.value</code> (<code>uint</code>)：与消息一起发送的 wei 数量</li>
<li><code>blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的哈希，当 <code>blocknumber</code> 是最近 256 个区块之一时；否则返回零</li>
<li><code>block.number</code> (<code>uint</code>)：当前区块编号</li>
<li><code>block.timestamp</code> (<code>uint</code>)：当前区块的时间戳，以自 Unix 纪元以来的秒数表示</li>
<li><code>msg.data</code> (<code>bytes calldata</code>)：完整的 calldata</li>
<li><code>msg.sig</code> (<code>bytes4</code>)：calldata 的前四个字节（即函数标识符）</li>
</ul>
<h4 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx.origin"></a>tx.origin</h4><p>在 Solidity 中，<code>tx.origin</code> 是一个全局变量，它表示发起当前交易的外部账户的地址。</p>
<ul>
<li>当一个外部账户直接发送一个交易时，<code>tx.origin</code> 就是该外部账户的地址。例如，如果你使用 MetaMask 从你的以太坊账户发送一个交易到一个智能合约，<code>tx.origin</code> 将是你在 MetaMask 中使用的以太坊账户地址。</li>
<li>然而，当一个智能合约调用另一个智能合约，而这个调用链最终是由一个外部账户发起的，<code>tx.origin</code> 仍然是最初发起该调用链的外部账户的地址，而不是中间的智能合约地址。</li>
</ul>
<p>假设一个外部账户 <code>Alice</code> 调用 <code>contract A</code> 的 <code>callB</code> 函数，<code>contract A</code> 再调用 <code>contract B</code> 的 <code>someFunction</code> 函数。在 <code>contract B</code> 的 <code>someFunction</code> 中：</p>
<ul>
<li><code>msg.sender</code> 将是 <code>contract A</code> 的地址，因为 <code>contract A</code> 是直接调用 <code>contract B</code> 的。</li>
<li><code>tx.origin</code> 将是 <code>Alice</code> 的地址，因为 <code>Alice</code> 是最初发起整个交易的外部账户。<br>在实际开发中，应谨慎使用 <code>tx.origin</code>，为了安全起见，通常更倾向于使用 <code>msg.sender</code> 进行身份验证和权限检查，因为使用 <code>tx.origin</code> 可能会导致合约被恶意合约利用，从而引发安全漏洞。</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在Solidity中，一个合约只能有一个构造函数。<br>原因：构造函数是在合约部署时执行初始化操作的特殊函数。如果允许多个构造函数，编译器将难以确定在部署合约时应该执行。<br>作用：初始化状态变量&#x2F;执行一次性配置。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    //角色：普通用户、医生、管理员</span><br><span class="line">    enum Role&#123;NormalUser,Doctor,Admin&#125;</span><br><span class="line"></span><br><span class="line">    //病历审核状态：待定、已通过、通过失败</span><br><span class="line">    enum RecordStatus&#123;Pending,Approved,Rejected&#125;</span><br></pre></td></tr></table></figure>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>声明映射的格式为&#96;mapping(_KeyType &#x3D;&gt; _ValueType)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    //映射：判断某个地址是否已经注册，避免重复注册</span><br><span class="line">    mapping(address=&gt;bool)public isUserRegistered;</span><br><span class="line">    </span><br><span class="line">    //注册系统时检查该地址是否已经被注册</span><br><span class="line">    require(!isUserRegistered[msg.sender],&quot;Error!User has already registered.&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>映射的存储位置只能是<code>storage</code>，不能声明为<code>memory</code>或<code>calldata</code>。</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="存储位置-storage-memory-calldata"><a href="#存储位置-storage-memory-calldata" class="headerlink" title="存储位置 storage|memory|calldata"></a>存储位置 storage|memory|calldata</h2><p>Solidity 中有三种数据存储位置，用于指定变量在区块链上的存储方式和生命周期。</p>
<ol>
<li>storage：数据存储在区块链的永久存储中（合约的状态变量默认为此类型），修改会消耗gas。只要合约存在，这些数据就一直存在，相当于把重要文件存放在一个长期的仓库中。</li>
<li>memory：数据<strong>临时</strong>存储在内存中，仅在函数执行期间存在。函数调用结束后，数据就会被销毁。就像在一个临时的工作区域处理数据，处理完就清理掉。修改不消耗额外gas（但分配内存会消耗）。 </li>
<li>calldata：用于函数的外部输入参数（如<code>external</code>函数的参数），是只读的临时数据，与<code>memory</code>类似但更节省 gas。<blockquote>
<p>为什么映射必须存在<code>storage</code>中？<br>映射的底层实现依赖于区块链的永久存储结构（<code>storage</code>）。它本质上是一种“键-值”对的哈希表，其数据存储在合约的状态存储中，通过键的哈希计算直接定位值的存储位置，这种机制与<code>storage</code>的布局紧密绑定。</p>
</blockquote>
</li>
</ol>
<h2 id="访问权限public-private-internal-external"><a href="#访问权限public-private-internal-external" class="headerlink" title="访问权限public|private|internal|external"></a>访问权限public|private|internal|external</h2><ul>
<li>public：任何人可调用（包括合约内部、外部合约、外部账户）。</li>
<li>private：仅能被当前合约内部访问（子类也不能调用）。</li>
<li>internal：当前合约及子类（继承它的合约）可调用。</li>
<li>external：仅外部可调用（外部合约或外部账户），合约内部不能直接调用（需用 <code>this.</code>）。例如接口函数、供外部交互的函数（如转账 <code>transfer</code>），使用<code>external</code>比<code>public</code>更节省gas。</li>
</ul>
<h2 id="函数修饰符-view-pure"><a href="#函数修饰符-view-pure" class="headerlink" title="函数修饰符 view|pure"></a>函数修饰符 view|pure</h2><p>作用：限制函数对合约状态的读写行为，目的是明确函数是否会修改区块链状态，同时帮助编译器优化gas消耗。</p>
<ul>
<li>view：看！只能读取数据不能更改数据。</li>
<li>pure：纯！纯用给的参数。<blockquote>
<p>非<code>view</code>且非<code>pure</code>，可以读取、修改状态变量。</p>
</blockquote>
</li>
</ul>
<h2 id="修饰器-modifier"><a href="#修饰器-modifier" class="headerlink" title="修饰器 modifier"></a>修饰器 modifier</h2><p>例如，有一个智能合约函数用来更新重要的数据，在调用这个函数之前，可能需要验证调用者是不是合约的拥有者。这个验证步骤就可以写成一个modifier 。当你定义好这个modifier并且应用到函数上之后，每次调用这个函数，就会先执行modifier里的验证规则，只有验证通过了，函数的主体部分才会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    // 定义modifier</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;只有合约所有者才能执行此操作&quot;);</span><br><span class="line">        _;_</span><br><span class="line">    &#125;</span><br><span class="line">    //某个函数添加onlyOwner关键字，每次执行前先按照修饰器逻辑检查</span><br><span class="line">    function setValue(uint256 _newValue) public onlyOwner &#123;</span><br><span class="line">        // 这里可以添加具体设置值的逻辑，比如更新某个变量的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><ol>
<li>Functions in interfaces must be declared external.</li>
<li>Functions in interfaces cannot have modifiers.</li>
<li>接口不仅能写函数，还能写状态变量。</li>
</ol>
<h2 id="继承-is"><a href="#继承-is" class="headerlink" title="继承 is"></a>继承 is</h2><p>继承是面向对象编程很重要的组成部分，可以显著减少重复代码。</p>
<ul>
<li><code>override</code>：子合约重写了父合约中的函数，需要加上<code>override</code>关键字。</li>
<li><code>virtual</code>: 父合约中的函数，如果希望子合约重写，需要加上<code>virtual</code>关键字。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//is这个关键字说明A是B的子合约</span><br><span class="line">contract A is B&#123;</span><br><span class="line">	//逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="导入-import"><a href="#导入-import" class="headerlink" title="导入 import"></a>导入 import</h2><p>在Solidity中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//引入第三方库</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">//引入其他文件</span><br><span class="line">import &quot;./someothercontract.sol&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="事件-event"><a href="#事件-event" class="headerlink" title="事件 event"></a>事件 event</h2><p>事件是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应<br>当合约执行到<code>emit</code>语句时，会将事件数据写入区块链日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    //事件：用户注册成功之后触发（注意：事件需要移至全局区域）</span><br><span class="line">    event UserRegistered(</span><br><span class="line">        uint256 indexed userId,</span><br><span class="line">        address indexed userAddress,</span><br><span class="line">        string userName,</span><br><span class="line">        Role role</span><br><span class="line">    );</span><br><span class="line">    //触发事件 关键字emit</span><br><span class="line">    emit UserRegistered(newUserId,msg.sender,_userName,_role);</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Solidity提供了多种异常处理机制，主要包括 <code>require</code>、<code>revert</code>、<code>assert</code> 三个关键字。</p>
<ol>
<li><code>require(检查条件，&quot;异常的描述&quot;)</code>，当检查条件不成立的时候为false，则触发异常，回滚所有状态变更，并将错误提示信息返回给调用者；如果为true，则继续执行。<blockquote>
<p> <em>若触发异常，会消耗已执行到当前步骤的 gas，但不会消耗后续未执行代码的 gas（相对经济）</em>。</p>
</blockquote>
</li>
<li><code>revert(&quot;错误提示信息&quot;);</code>直接终止执行，回滚状态变更，返回错误信息，属于主动触发，更适合在复杂逻辑（如多分支判断）后抛出异常。<blockquote>
<p><em>与<code>require</code> 相同，仅消耗到当前步骤的 gas。</em></p>
</blockquote>
</li>
<li><code>assert(条件表达式)</code>，如果 <code>条件表达式</code> 为false，触发异常并回滚状态；若为true，继续执行。<blockquote>
<p><em>若触发异常，<strong>会消耗所有剩余 gas</strong>（非常昂贵），因此不适合用于验证用户输入或外部条件。</em></p>
</blockquote>
</li>
</ol>
<p>Solidity 0.8.4 引入了自定义错误，相比字符串错误信息（<code>require</code>&#x2F;<code>revert</code> 的提示），<strong>自定义错误更节省 gas</strong>，尤其适合高频调用的函数。</p>
<ol>
<li>定义自定义错误：在合约内用 <code>error</code> 关键字声明（类似事件）。</li>
<li>触发自定义错误：用 <code>revert</code> 关键字触发。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义自定义错误（可带参数）</span><br><span class="line">error InsufficientBalance(uint256 available, uint256 required);</span><br><span class="line">error InvalidReceiver(address receiver);</span><br><span class="line"></span><br><span class="line">// 触发自定义错误</span><br><span class="line">if (to == address(0)) &#123;</span><br><span class="line">    revert InvalidReceiver(to); </span><br><span class="line">&#125;</span><br><span class="line">if (balances[msg.sender] &lt; amount) &#123;</span><br><span class="line">    revert InsufficientBalance(balances[msg.sender], amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><h3 id="fallback-与receive"><a href="#fallback-与receive" class="headerlink" title="fallback()与receive()"></a>fallback()与receive()</h3><table>
<thead>
<tr>
<th>维度</th>
<th>纯 ETH 交易</th>
<th>函数调用交易</th>
</tr>
</thead>
<tbody><tr>
<td>目的</td>
<td>仅转移 ETH</td>
<td>触发合约特定函数逻辑</td>
</tr>
<tr>
<td>交互对象</td>
<td>EOA 或合约账户（但不调用函数）</td>
<td>必须是合约账户（调用其函数）</td>
</tr>
<tr>
<td><code>data</code>字段</td>
<td>为空（<code>0x</code>）</td>
<td>非空，包含函数选择器和参数</td>
</tr>
<tr>
<td>触发的合约行为</td>
<td>若接收方是合约，仅触发<code>fallback</code>&#x2F;<code>receive</code></td>
<td>触发指定函数的完整逻辑</td>
</tr>
<tr>
<td>典型场景</td>
<td>用户间 ETH 转账</td>
<td>代币转账、NFT 铸造、DeFi 操作等</td>
</tr>
<tr>
<td>例子</td>
<td><code>contractAddress.send(1 ether)</code></td>
<td><code>contract.deposit&#123;value: 1 ether&#125;()</code></td>
</tr>
<tr>
<td><code>receive()</code>是 Solidity 0.6.0 引入的特殊函数，专门用于处理<strong>纯 ETH 转账</strong>（即交易的 <code>data</code> 为空，仅发送 ETH）。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>声明条件</strong>：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>函数声明必须为 <code>external payable</code>（<code>payable</code> 表示可接收 ETH，<code>external</code> 表示仅外部可调用）。</li>
<li>不能有参数，不能有返回值。</li>
<li>不能有函数修饰符（如 <code>view</code>、<code>pure</code> 等）。<br><strong>触发条件</strong>：</li>
<li>交易的 <code>to</code> 是当前合约地址；</li>
<li>交易的 <code>value</code>（发送的 ETH 数量）大于 0；</li>
<li>交易的 <code>data</code> 字段为空（<code>0x</code>）；</li>
<li>合约已定义 <code>receive()</code> 函数（<em>若未定义，会尝试触发 <code>fallback()</code></em>）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//正确声明</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    // 处理纯 ETH 接收的逻辑（如记录余额）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fallback()</code> 是更早存在的特殊函数，用于处理<strong>未被匹配的交易</strong>，包括两种场景：带数据的 ETH 转账，或调用不存在的函数。<br><strong>语法规则</strong>：</p>
<ul>
<li>函数声明为 <code>external payable</code>（<code>payable</code> 可选：若需接收 ETH，则必须加 <code>payable</code>；若不接收，可省略）。</li>
<li>不能有参数，不能有返回值。</li>
<li>不能有函数修饰符。<br><strong>触发条件</strong>：<br>满足以下任一条件时触发：</li>
</ul>
<ol>
<li>交易向合约发送 ETH（<code>value &gt; 0</code>），且 <code>data</code> 字段非空（带数据），且合约未定义 <code>receive()</code> 函数；</li>
<li>调用合约中<strong>不存在的函数</strong>（无论是否带 ETH）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 可接收 ETH 的 fallback</span><br><span class="line">fallback() external payable &#123;</span><br><span class="line">    // 处理带数据的 ETH 或未定义函数调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不可接收 ETH 的 fallback（若收到 ETH 会报错）</span><br><span class="line">fallback() external &#123;</span><br><span class="line">    // 仅处理不带 ETH 的未定义函数调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="散列函数keccak256"><a href="#散列函数keccak256" class="headerlink" title="散列函数keccak256"></a>散列函数keccak256</h3><p>keccak256是 Solidity 中内置的一个全局函数，用于计算数据的 <strong>Keccak-256</strong> 散列值。</p>
<p>它是Ethereum 内部有一个散列函数，它用了SHA3版本。<strong>它接收任意长度的输入，并输出一个固定长度的 32 字节 (256 位)的散列值</strong>。字符串的一个微小变化会引起散列数据极大变化。</p>
<p>功能：提供数据的<strong>唯一性</strong>和<strong>完整性验证</strong>，并实现一些高级的合约逻辑。</p>
<ol>
<li>唯一性：就是将任意数据（如字符串、数字、地址等）转化为一个唯一的、不可逆的 32 字节“指纹”。用于数据承诺 (Data Commitments)、生成唯一 ID以及地址的生成（例如，通过 <code>ecrecover</code> 验证签名时，需要先对数据进行散列）</li>
<li>完整性验证：对输入数据进行微小的改动，都会导致输出的散列值发生巨大的、不可预测的变化（雪崩效应）。用于验证数据在传输或存储过程中是否被篡改。显而易见，下面这个例子中，输入字符串只改变了一个字母，输出就已经天壤之别了。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5 keccak256(&quot;aaaab&quot;); //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9 keccak256(&quot;aaaac&quot;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>生成伪随机数：虽然散列函数本身是确定性的，但在无法预知输入的情况下，其输出看起来是随机的。有限地用于生成不会影响核心安全的“伪随机数”，例如游戏中的装饰性元素。 由于矿工可以预知或影响输入，<strong>绝对不能</strong>将 <code>keccak256</code>作为生成安全随机数的唯一方法来决定资金分配或关键游戏结果。</li>
<li>高级逻辑实现：Merkle证明，在实现默克尔树 (Merkle Tree)相关的逻辑时，<code>keccak256</code> 是基础组件，用于验证一个数据点是否属于一个预先承诺的集合（例如空投、白名单）。</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>Solidity不允许“跨尺寸直接转换”，主要是为了防止意外的数据丢失</strong>。比如从大尺寸转到小尺寸时的数据截断。但允许“扩大转换”，将小尺寸类型转换为大尺寸类型是允许的，因为这不会丢失任何数据，只是在高位填充零。<br>举个例子，uint256(uint160(msg.sender))，address占20个字节，uint160也占20个字节，uint256占32个字节，那为什么不直接转换？尽管是“扩大”，但 Solidity 也避免这种不明确的、跨语义类型的直接跳跃，它强制您使用中间类型。</p>
<h2 id="存储槽"><a href="#存储槽" class="headerlink" title="存储槽"></a>存储槽</h2><p>在以太坊智能合约中，<strong>存储槽（Storage Slot）是用于存储合约状态变量的基本单位</strong>。</p>
<ol>
<li>定义：*每个存储槽是一个固定大小的 <strong>32 字节 (256 位)</strong> 空间。</li>
<li>编号： 存储槽从 槽 0 (Slot 0)开始，依次编号为 $0, 1, 2, 3, \ldots$。</li>
<li>持久性： 合约中被声明为状态变量的数据（即在函数外部声明的变量）都永久地存储在这些槽中。修改存储槽是EVM中最昂贵的操作之一（因为数据必须被永久记录到区块链上）。</li>
</ol>
<p>这些存储位置的分配有什么影响？数据是怎么排列存储到对应的位置上的？<br>Solidity编译器采用一套严格的规则来决定状态变量如何被打包和分配到存储槽中，<strong>目的是尽可能节省Gas成本</strong>。基本原则是合约中的状态变量是<strong>按照它们声明的顺序，从槽0开始依次分配的</strong>。其次，为了节省空间和 Gas，Solidity 会尝试将<strong>多个小于 32 字节的变量打包到一个存储槽中</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint256 totalBalance; // 槽 0 (32 字节)</span><br><span class="line"></span><br><span class="line">uint8 flag1;         // 槽 1 开始</span><br><span class="line">uint8 flag2;</span><br><span class="line">uint256 timestamp;   // 槽 2 开始 (因为 flag1 和 flag2 加起来只有2字节)</span><br></pre></td></tr></table></figure>
<ol>
<li>结构体 (<code>struct</code>) 或静态大小的数组：<br> <strong>总是从一个新的存储槽开始</strong>。结构体&#x2F;静态数组<strong>之后</strong>的任何状态变量，也总是从一个新的存储槽开始。</li>
<li>映射与动态数组：<br> 它们本身在状态变量序列中只占用 <strong>一个 32 字节的槽 P</strong>（主槽Slot P）。这个槽 P 存储的不是数据，而是<strong>指向数据存储位置的指针</strong>。那么数据位置在哪里？它们内部的元素被存储在另一个计算出的位置，这个位置是通过对槽 P 进行 <code>keccak256</code> 哈希计算得出的。<br> 数据存储的起始位置&#x3D; keccak256(P)</li>
<li><strong>bytes和string</strong>：<br> 短数据（Short）： 如果长度小于 32 字节，数据和长度信息会被打包存储在同一个槽 P 中。<br>  长数据（Long）： 如果长度大于等于 32 字节，<strong>槽 P 只存储数据的长度，而实际数据被存储在 $\text{keccak256}(\text{P})$ 处</strong>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line">    bool public locked = true;</span><br><span class="line">    uint256 public ID = block.timestamp;</span><br><span class="line">    uint8 private flattening = 10;</span><br><span class="line">    uint8 private denomination = 255;</span><br><span class="line">    uint16 private awkwardness = uint16(block.timestamp);</span><br><span class="line">    bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">        data = _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    function unlock(bytes16 _key) public &#123;</span><br><span class="line">        require(_key == bytes16(data[2]));</span><br><span class="line">        locked = false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>1.Solidity 变量按声明顺序存储，存储槽分配如下：</p>
<ul>
<li><code>locked</code>（bool） → ​<strong>槽0</strong>​（1字节）</li>
<li><code>ID</code>（uint256） → ​<strong>槽1</strong>​（32字节）</li>
<li><code>flattening</code>（uint8）、<code>denomination</code>（uint8）、<code>awkwardness</code>（uint16） → ​<strong>槽2</strong>​（4字节，填充到32字节）</li>
<li><code>data[0]</code> → ​<strong>槽3</strong></li>
<li><code>data[1]</code> → ​<strong>槽4</strong></li>
<li><code>data[2]</code> → ​<strong>槽5</strong><br>2.读取槽5的数据：使用工具（如 <code>web3.js</code> 或 <code>ethers.js</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data2 = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contractAddress, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong>：<br>如何将<code>data2</code> 转换为<code> bytes16</code>（取前16字节）作为<code>_key</code>?</p>
<ul>
<li>首先，存储槽5中的数据<code>bytes32</code>是一个32字节的十六进制字符串，比如<code>0x</code>开头加上64个字符。<code>bytes16</code>需要的是前32个字符（16字节）。</li>
<li>例如，如果<code>data2</code>是<code>0xaabbccddeeff00112233445566778899aabbccddeeff00112233445566778899</code>，那么前16字节是<code>0xaabbccddeeff00112233445566778899</code>，对应的<code>bytes16</code>就是取前32个字符（去掉<code>0x</code>后的前32位）。</li>
</ul>
<p>eg1.在合约中直接使用 <code>bytes16(data[2])</code> 时，Solidity 会自动截取 <code>data[2]</code> 的前 16 字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes32 value = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;</span><br><span class="line">bytes16 key = bytes16(value); // 结果为 0x1234567890abcdef1234567890abcdef</span><br></pre></td></tr></table></figure>

<h2 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h2><p>JSON-RPC 是一种无状态、远程过程调用 (RPC) 协议，它使用 <strong>JSON (JavaScript Object Notation)</strong> 作为数据传输格式。<br>在以太坊生态系统的语境中，<strong>JSON-RPC</strong> 是一种至关重要的通信协议，它是<strong>智能合约、以太坊节点和用户界面 (Web App&#x2F;Wallet) 之间进行交互的桥梁。</strong><br>Solidity 本身是一种编程语言，用于编写智能合约。它不直接包含 JSON-RPC，但你部署的合约必须通过 JSON-RPC 才能被外界访问。</p>
<h2 id="abi函数"><a href="#abi函数" class="headerlink" title="abi函数"></a>abi函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address user1 = 0x1234...; bytes memory packed = abi.encodePacked(user1); // 结果：0x0000000000000000000000001234... (20字节)</span><br></pre></td></tr></table></figure>
<p><strong>encodePacked vs encode 的区别</strong>：</p>
<ul>
<li><code>abi.encodePacked()</code>: <strong>紧密打包</strong>，去掉填充，节省空间</li>
<li><code>abi.encode()</code>: <strong>标准打包</strong>，有固定的填充规则</li>
</ul>
<h2 id="Call函数"><a href="#Call函数" class="headerlink" title="Call函数"></a>Call函数</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 示例<span class="number">1</span>：纯转账（不调用函数） (bool success, ) = <span class="built_in">address</span>(cryptoKeeper1).<span class="built_in">call</span>&#123;val<span class="symbol">ue:</span> <span class="number">10</span> ether&#125;(<span class="string">&quot;&quot;</span>); // 示例<span class="number">2</span>：调用函数并转账 (bool success, ) = <span class="built_in">address</span>(cryptoKeeper1).<span class="built_in">call</span>&#123;val<span class="symbol">ue:</span> <span class="number">1</span> ether&#125;( abi.encodeWithSignature(<span class="string">&quot;deposit()&quot;</span>) ); // 示例<span class="number">3</span>：只调用函数，不转账 (bool success, bytes memory result) = <span class="built_in">address</span>(token).<span class="built_in">call</span>( abi.encodeWithSignature(<span class="string">&quot;balanceOf(address)&quot;</span>, user1) );</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/0xMarch-food">March</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/08/17/Solidity/">http://example.com/2025/08/17/Solidity/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">March</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web3%E6%A0%B8%E5%BF%83/">Web3核心</a><a class="post-meta__tags" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/">智能合约</a><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div><div class="post-share"><div class="social-share" data-image="/img/post1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/25/%E5%89%8D%E7%AB%AFJavaScript/" title="前端JavaScript"><img class="cover" src="/img/post3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">前端JavaScript</div></div><div class="info-2"><div class="info-item-1">JavaScript 是脚本语言，实现人机互动。JS权威网站：MDN Web Docs作用：网页特效、表单验证、数据交互、服务端编程 开始前端JS &#x3D; 语法基础 + Web APIsJS书写位置：  内部 外部（外部JS标签中间不要写代码，会被忽略）  1&lt;script src=&quot;./alert.js&quot;&gt;&lt;/script&gt;  内联  1&lt;button onclick=&quot;alert(&#x27;骗你的&#x27;)&quot;&gt;点击我月薪过万&lt;/button&gt; JS末尾分号可写可不写注释：//单行注释与  /*多行注释内容*/ 输入输出 输出语句（1）  1document.write(&#x27;内容&#x27;) 作用：向body内输出内容注意：即使有标签，也会被解析（2） 1alert(&#x27;内容‘) 作用：页面弹出警告对话框（3） 1console.log(&#x27;内容&#x27;) 作用：控制台输出语法，调试使用  输入语句  1prompt(&#x27;请输入您的学号：&#...</div></div></div></a><a class="pagination-related" href="/2025/08/17/hello-world/" title="Hello World"><img class="cover" src="/img/xixi.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/11/20/Rust/" title="Rust"><img class="cover" src="/img/post9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-20</div><div class="info-item-2">Rust</div></div><div class="info-2"><div class="info-item-1">学习网站：【官方文档】[https://doc.rust-lang.org/book/title-page.html]【HOH共学营】[https://github.com/gpteth/lets-rust/blob/main/tutorial/02_memory_management.md] 开始先搭建环境，太久远了，这里不赘述了，可去官网下载。以下命令最好在GitBash里面执行。创建新项目： 1cargo new &lt;hello-rust&gt; 有可能： 1cargo new --lib my_lib 编译并运行： 12cargo buildcargo run 基础编程概念关于变量一旦将值绑定到名称，就无法更改该值。 1234567fn main() &#123;    let x = 5;    println!(&quot;The value of x is: &#123;x&#125;&quot;);    //错误!    x = 6;    println!(&quot;The value of x is: &#123;x&#125;&quot;);&#12...</div></div></div></a><a class="pagination-related" href="/2025/10/23/ERC20/" title="ERC20"><img class="cover" src="/img/post6.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">ERC20</div></div><div class="info-2"><div class="info-item-1">什么是ERC20？就是一份技术规范（一键发币模板）。2017年定稿。从此任何钱包交易所与DApp都不再需要为每个新代币进行定制开发，直接用这个模板就行。  EIP-20（全称为 Ethereum Improvement Proposal 20），也常被称为 “ERC-20 标准”（ERC 即 Ethereum Request for Comments，是 EIP 被社区接受后的正式名称）。它定义了 fungible token（可替代代币）的统一接口规范，让不同代币在以太坊网络中能被一致地交互和管理。  内容ERC20标准提供了name、symbol、decimals等元数据接口，用于描述代币的基本信息，如名称、符号和小数位数，方便用户识别和使用。 6个函数 总供应量  1function totalSupply() public view returns (uint256)  转账（从自己账户直接转移代币）  1function transfer(address _to, uint256 _value) public returns (bool success)  余额查询  ...</div></div></div></a><a class="pagination-related" href="/2025/10/23/HardHat/" title="HardHat框架"><img class="cover" src="/img/post5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">HardHat框架</div></div><div class="info-2"><div class="info-item-1">开始安装并初始化12cd ...npx hardhat --init  使用 OpenZepplin 等第三方库： 1npm install @openzeppelin/contracts --save-dev  在合约里的体现： 1import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;  编译合约1npx hardhat compile  成功编译后，会在  artifacts/contracts/  目录下生成Name.json ，包含了智能合约的 ABI 、字节码（Bytecode）等。 运行测试12npx hardhat testnpx hardhat test &lt;文件名&gt;  其实我们在测试时， 合约已经部署到了 Hardhat 内置的网络上。 部署合约在scripts文件夹，新建一个deploy.js  用来写部署脚本。 12345678# 部署到Hardhat的「默认内置网络」npx hardhat run scripts/deploy.js# 本地部署npx hardhat ru...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">March</div><div class="author-info-description">Major in BlackChain | Web3 learner</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0xMarch-food"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这里是对自己一些学习内容的记录，欢迎探讨指正！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">代码框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">2.</span> <span class="toc-text">版本号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">数据类型的默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.</span> <span class="toc-text">1. 状态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">2. 局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.3.</span> <span class="toc-text">3. 全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tx-origin"><span class="toc-number">6.3.1.</span> <span class="toc-text">tx.origin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">8.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">9.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">10.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-storage-memory-calldata"><span class="toc-number">11.</span> <span class="toc-text">存储位置 storage|memory|calldata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90public-private-internal-external"><span class="toc-number">12.</span> <span class="toc-text">访问权限public|private|internal|external</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6-view-pure"><span class="toc-number">13.</span> <span class="toc-text">函数修饰符 view|pure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%99%A8-modifier"><span class="toc-number">14.</span> <span class="toc-text">修饰器 modifier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="toc-number">15.</span> <span class="toc-text">接口 interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-is"><span class="toc-number">16.</span> <span class="toc-text">继承 is</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-import"><span class="toc-number">17.</span> <span class="toc-text">导入 import</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-event"><span class="toc-number">18.</span> <span class="toc-text">事件 event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">19.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0"><span class="toc-number">20.</span> <span class="toc-text">特殊函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fallback-%E4%B8%8Ereceive"><span class="toc-number">20.1.</span> <span class="toc-text">fallback()与receive()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0keccak256"><span class="toc-number">20.2.</span> <span class="toc-text">散列函数keccak256</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">21.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%A7%BD"><span class="toc-number">22.</span> <span class="toc-text">存储槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E5%8D%8F%E8%AE%AE"><span class="toc-number">23.</span> <span class="toc-text">RPC协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abi%E5%87%BD%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">abi函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Call%E5%87%BD%E6%95%B0"><span class="toc-number">25.</span> <span class="toc-text">Call函数</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/05/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="密码学">密码学</a><time datetime="2025-12-06T10:09:13.243Z" title="更新于 2025-12-06 18:09:13">2025-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/20/Rust/" title="Rust">Rust</a><time datetime="2025-12-04T06:38:29.958Z" title="更新于 2025-12-04 14:38:29">2025-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/24/Java/" title="Java">Java</a><time datetime="2025-12-02T04:17:57.627Z" title="更新于 2025-12-02 12:17:57">2025-12-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/post1.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By March</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>